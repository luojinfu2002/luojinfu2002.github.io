

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/2.png">
  <link rel="icon" href="/img/2.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="luo">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、汇编语言是什么？我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。 这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。 对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编学习">
<meta property="og:url" content="http://example.com/2023/03/27/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Luo&#39;s Blog">
<meta property="og:description" content="一、汇编语言是什么？我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。 这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。 对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281441087.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281451635.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281500821.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281502145.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281503456.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281504175.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281505057.png">
<meta property="og:image" content="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012216.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241624754.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241653434.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241656064.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241657443.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241658819.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241659028.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241701514.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241703503.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241704250.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241704111.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241705170.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241705976.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241706350.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241707552.png">
<meta property="og:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241708313.png">
<meta property="article:published_time" content="2023-03-27T14:38:12.301Z">
<meta property="article:modified_time" content="2023-08-01T04:42:02.355Z">
<meta property="article:author" content="luo">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281441087.png">
  
  
  
  <title>汇编学习 - Luo&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Luo's Blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Luo&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">汇编学习</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-27 22:38" pubdate>
          2023年3月27日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          173 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">汇编学习</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="一、汇编语言是什么？"><a href="#一、汇编语言是什么？" class="headerlink" title="一、汇编语言是什么？"></a>一、汇编语言是什么？</h2><p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p>
<p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/11/compiler.html">编译器</a>的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p>
<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>
<p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>
<h2 id="二、来历"><a href="#二、来历" class="headerlink" title="二、来历"></a>二、来历</h2><p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p>
<p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。</p>
<p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做  assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为  asm，中文译为汇编语言。每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p>
<h2 id="三、寄存器"><a href="#三、寄存器" class="headerlink" title="三、寄存器"></a>三、寄存器</h2><p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p>
<p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU  的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>
<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU  还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU  优先读写寄存器，再由寄存器跟内存交换数据。</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281441087.png" srcset="/img/loading.gif" lazyload alt="image-20230328144102980"></p>
<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p>
<h2 id="四、寄存器的种类"><a href="#四、寄存器的种类" class="headerlink" title="四、寄存器的种类"></a>四、寄存器的种类</h2><p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。一般寄存器:AX、BX、CX、DX，索引暂存器:SI、DI，堆叠、基底暂存器:SP、BP。EAX、ECX、EDX、EBX：为ax,bx,cx,dx的延伸，各为32位元<br>ESI、EDI、ESP、EBP：为si,di,sp,bp的延伸，32位元。eax, ebx, ecx, edx, esi, edi, ebp, esp等都是X86 汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。如果用C语言来解释，可以把这些寄存器当作变量看待。</p>
<p>这些32位寄存器有多种用途，但每一个都有“专长”，有各自的特别之处。</p>
<p>EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。</p>
<p>EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址。</p>
<p>ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。</p>
<p>EDX 则总是被用来放整数除法产生的余数。</p>
<p>ESI&#x2F;EDI分别叫做”源&#x2F;目标索引寄存器”(source&#x2F;destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.</p>
<blockquote>
<p>​	push ebp ;保存当前ebp<br>　mov ebp,esp ;EBP设为当前堆栈指针<br>　sub esp, xxx ;预留xxx字节给函数临时变量.<br>　…　　</p>
</blockquote>
<p>这样一来,EBP 构成了该函数的一个框架, 在EBP上方分别是原来的EBP, 返回地址和参数. EBP下方则是临时变量. 函数返回时作 mov esp,ebp&#x2F;pop ebp&#x2F;ret 即可.</p>
<p>ESP 专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。</p>
<p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p>
<h2 id="五、内存模型：Heap"><a href="#五、内存模型：Heap" class="headerlink" title="五、内存模型：Heap"></a>五、内存模型：Heap</h2><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>
<img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281451635.png" srcset="/img/loading.gif" lazyload width="40%">

<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p>
<img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281500821.png" srcset="/img/loading.gif" lazyload width="40%/">

<p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>
<h2 id="六、内存模型：Stack"><a href="#六、内存模型：Stack" class="headerlink" title="六、内存模型：Stack"></a>六、内存模型：Stack</h2><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p>
<img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281502145.png" srcset="/img/loading.gif" lazyload width="40%/">

<p>请看下面的例子。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clike">int main() &#123;<br>   int a = 2;<br>   int b = 3;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p>
<img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281503456.png" srcset="/img/loading.gif" lazyload width="40%">

<p>如果函数内部调用了其他函数，会发生什么情况？</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clike">int main() &#123;<br>   int a = 2;<br>   int b = 3;<br>   return add_a_and_b(a, b);<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p>
<img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281504175.png" srcset="/img/loading.gif" lazyload width="40%">

<p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>
<p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是  push；栈的回收叫做”出栈”，英文是 pop。Stack  的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p>
<p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p>
<img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281505057.png" srcset="/img/loading.gif" lazyload width="40%">

<h2 id="七、CPU-指令"><a href="#七、CPU-指令" class="headerlink" title="七、CPU 指令"></a>七、CPU 指令</h2><h3 id="7-1-一个实例"><a href="#7-1-一个实例" class="headerlink" title="7.1 一个实例"></a>7.1 一个实例</h3><p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clike">int add_a_and_b(int a, int b) &#123;<br>   return a + b;<br>&#125;<br><br>int main() &#123;<br>   return add_a_and_b(2, 3);<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>gcc 将这个程序转成汇编语言。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -S example.c<br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p>
<p><code>example.s</code>经过简化以后，大概是下面的样子。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clike">_add_a_and_b:<br>push   %ebx	//esp-4<br>mov    %eax, [%esp+8]	// 取2<br>mov    %ebx, [%esp+12]	// 取3<br>add    %eax, %ebx	//a+b值存在eax中<br>pop    %ebx	//ebx弹出栈，esp+4<br>ret	//退出程序执行<br><br>_main:<br>push   3	//压栈，整型占4字节，esp栈顶指针-4<br>push   2	//压栈，esp-4<br>call   _add_a_and_b	//调用add函数<br>add    %esp, 8 //esp+8 保存在esp中<br>ret	//退出程序执行<br></code></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p>
<p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   %ebx<br></code></pre></td></tr></table></figure>
</blockquote>
<p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p>
<p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p>
<h3 id="7-2-push-指令"><a href="#7-2-push-指令" class="headerlink" title="7.2 push 指令"></a>7.2 push 指令</h3><p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p>
<p>然后，开始执行第一行代码。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   3<br></code></pre></td></tr></table></figure>
</blockquote>
<p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p>
<p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   2<br></code></pre></td></tr></table></figure>
</blockquote>
<p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012216.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="7-3-call-指令"><a href="#7-3-call-指令" class="headerlink" title="7.3 call 指令"></a>7.3 call 指令</h3><p>第三行的<code>call</code>指令用来调用函数。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">call   _add_a_and_b<br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p>
<p>下面就开始执行<code>_add_a_and_b</code>的代码。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   %ebx<br></code></pre></td></tr></table></figure>
</blockquote>
<p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p>
<p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p>
<h3 id="7-4-mov-指令"><a href="#7-4-mov-指令" class="headerlink" title="7.4 mov 指令"></a>7.4 mov 指令</h3><p><code>mov</code>指令用于将一个值写入某个寄存器。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">mov    %eax, [%esp+8] <br></code></pre></td></tr></table></figure>
</blockquote>
<p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p>
<p>下一行代码也是干同样的事情。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">mov    %ebx, [%esp+12] <br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p>
<h3 id="7-5-add-指令"><a href="#7-5-add-指令" class="headerlink" title="7.5 add 指令"></a>7.5 add 指令</h3><p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">add    %eax, %ebx<br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p>
<h3 id="7-6-pop-指令"><a href="#7-6-pop-指令" class="headerlink" title="7.6 pop 指令"></a>7.6 pop 指令</h3><p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">pop    %ebx<br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p>
<p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p>
<h3 id="7-7-ret-指令"><a href="#7-7-ret-指令" class="headerlink" title="7.7 ret 指令"></a>7.7 ret 指令</h3><p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">ret<br></code></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，该指令没有运算子。</p>
<p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">add    %esp, 8 <br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">ret<br></code></pre></td></tr></table></figure>
</blockquote>
<p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>
<hr>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span> <span class="hljs-built_in">bx</span> //取<span class="hljs-built_in">bx</span>寄存器的值送到<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span> <span class="hljs-number">18</span> //<span class="hljs-built_in">ax</span> = <span class="hljs-number">18</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span> <span class="hljs-built_in">bx</span> //<span class="hljs-built_in">ax</span> = <span class="hljs-built_in">ax</span>+<span class="hljs-built_in">bx</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span> <span class="hljs-number">7</span> //<span class="hljs-built_in">ax</span> = <span class="hljs-built_in">ax</span>+<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<p>字节：记为byte，一个字节由8个bit组成。</p>
<p>字：记为word，一个字由两个字节组成，这两个字节分别成为这个字的高位字节和低位字节。</p>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><h3 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h3><p>机器语言是0101，汇编语言是机器语言的助记符，每种cpu都有自己的汇编指令集。</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241624754.png" srcset="/img/loading.gif" lazyload alt="image-20230724162413568"></p>
<h3 id="1-2-单位"><a href="#1-2-单位" class="headerlink" title="1.2 单位"></a>1.2 单位</h3><p>1Byte(B) &#x3D; 8 bit, 1 Word &#x3D; 2 Byte,  1KB &#x3D; 1024 B, 1 MB &#x3D; 1024 KB, 1 GB &#x3D; 1024 MB, 1 TB &#x3D; 1024GB</p>
<p>DW 是定义2字节空间的意思。DW属于汇编的一个伪指令，DW定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2。</p>
<p>DB定义字节类型变量，一个字节数据占1个字节单元，读完一个，偏移量加1。</p>
<p>DD定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4。</p>
<p>基本数据度量单位:<br>1 BYTE(字节)&#x3D; 8 BIT(比特)<br>WORD&#x3D;2BYTE&#x3D;16BIT<br>DWORD&#x3D; 4 BYTE &#x3D; 32 BIT<br>QWORD&#x3D; 8BYTE &#x3D; 64 BIT<br>数据存储度量单位:<br>1KB&#x3D; 1024 BYTE &#x3D; 8192 BIT<br>1MB &#x3D; 1024KB<br>1GB &#x3D; 1024MB<br>1TB &#x3D; 1024GB</p>
<p>取值范围:<br>BYTE&#x3D;有符号:-128至127|无符号:0至255<br>WORD &#x3D;有符号: -32768 至32767 |无符号: 0至65535<br>DWORD &#x3D;有符号: -2,147 ,483,648至2, 147 ,483,647|无符号: 0至4,294,967 ,295<br>QWORD&#x3D;有符号: -9,223,372,036,854,775,808 至9,223,372,036,854,775 807</p>
<h3 id="1-3-CPU-对存储器的读写"><a href="#1-3-CPU-对存储器的读写" class="headerlink" title="1.3 CPU 对存储器的读写"></a>1.3 CPU 对存储器的读写</h3><p>1.地址总线  2.数据总线 3.控制总线  4.I&#x2F;O总线</p>
<p>地址总线的宽度决定了cpu的寻址能力，数据总线的宽度决定了cpu与其他器件进行数据传输时的一次数据传输量；控制总线的宽度决定了cpu对系统中其他器件的控制能力。</p>
<h3 id="1-4-各存储器芯片"><a href="#1-4-各存储器芯片" class="headerlink" title="1.4 各存储器芯片"></a>1.4 各存储器芯片</h3><p>存储器都与cpu的主线相连，cpu对他们进行读或写的时候通过控制线发出读写命令。</p>
<ul>
<li>随机存储器</li>
</ul>
<p>用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展插槽上的RAM。</p>
<ul>
<li>装有BIOS(Basic Input&#x2F;Output System，基本输入&#x2F;输出系统)的ROM</li>
</ul>
<p>BIOS是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。例如，主板上的ROM中存储着主板的BIOS(通常称为系统BIOS);显卡上的ROM中存储着显卡的BIOS;如果网卡上装有ROM，那其中就可以存储网卡的BIOS。</p>
<ul>
<li>接口卡上的RAM</li>
</ul>
<p>某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM。最典型的是显示卡上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。</p>
<h2 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2.寄存器"></a>2.寄存器</h2><p><strong>x86&#x2F;x64架构</strong>的CPU中的寄存器</p>
<h3 id="2-1-什么是寄存器？"><a href="#2-1-什么是寄存器？" class="headerlink" title="2.1 什么是寄存器？"></a>2.1 什么是寄存器？</h3><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果以及一些CPU运行需要的信息。</p>
<p>x86架构CPU走的是<strong>复杂指令集（CISC）</strong> 路线，提供了丰富的指令来实现强大的功能，与此同时也提供了大量寄存器来辅助功能实现。</p>
<h3 id="2-2通用寄存器"><a href="#2-2通用寄存器" class="headerlink" title="2.2通用寄存器"></a>2.2通用寄存器</h3><p>首先是通用寄存器，这些的寄存器是程序执行代码最最常用，也最最基础的寄存器，程序执行过程中，绝大部分时间都是在操作这些寄存器来实现指令功能。</p>
<p>所谓通用，即这些寄存器CPU没有特殊的用途，交给应用程序“随意”使用。注意，这个随意，我打了引号，对于有些寄存器，CPU有一些潜规则，用的时候要注意。</p>
<ul>
<li><strong>eax</strong>: 通常用来执行加法，函数调用的返回值一般也放在这里面</li>
<li><strong>ebx</strong>: 数据存取</li>
<li><strong>ecx</strong>: 通常用来作为计数器，比如for循环</li>
<li><strong>edx</strong>: 读写I&#x2F;O端口时，edx用来存放端口号</li>
<li><strong>esp</strong>: 栈顶指针，指向栈的顶部</li>
<li><strong>ebp</strong>: 栈底指针，指向栈的底部，通常用<code>ebp+偏移量</code>的形式来定位函数存放在栈中的局部变量</li>
<li><strong>esi</strong>: 字符串操作时，用于存放数据源的地址</li>
<li><strong>edi</strong>: 字符串操作时，用于存放目的地址的，和esi两个经常搭配一起使用，执行字符串的复制等操作</li>
</ul>
<p>在x64架构中，上面的通用寄存器都扩展成为64位版本，名字也进行了升级。当然，为了兼容32位模式程序，使用上面的名字仍然是可以访问的，相当于访问64位寄存器的低32位。</p>
<blockquote>
<p>rax rbx rcx rdx rsp rbp rsi rdi</p>
</blockquote>
<p>除了扩展原来存在的通用寄存器，x64架构还引入了8个新的通用寄存器：</p>
<blockquote>
<p><strong>r8-r15</strong></p>
</blockquote>
<p>在原来32位时代，函数调用时，那个时候通用寄存器少，参数绝大多数时候是通过线程的栈来进行传递（当然也有使用寄存器传递的，比如著名的C++ <strong>this指针</strong>使用ecx寄存器传递，不过能用的寄存器毕竟不多）。</p>
<p>进入x64时代，寄存器资源富裕了，参数传递绝大多数都是用寄存器来传了。<strong>寄存器传参的好处是速度快，减少了对内存的读写次数。</strong></p>
<p>当然，具体使用栈还是用寄存器传参数，这个不是编程语言决定的，而是编译器在编译生成CPU指令时决定的，如果编译器非要在x64架构CPU上使用线程栈来传参那也不是不行，这个对高级语言是无感知的。</p>
<h3 id="2-2标志寄存器"><a href="#2-2标志寄存器" class="headerlink" title="2.2标志寄存器"></a>2.2标志寄存器</h3><p>标志寄存器，里面有众多标记位，记录了CPU执行指令过程中的一系列状态，这些标志大都由CPU自动设置和修改：</p>
<ul>
<li>CF 进位标志（1进0不进）</li>
<li>PF 奇偶标志（1的个数为偶数是1，否则为0）</li>
<li>ZF 零标志（0为1）</li>
<li>SF 符号标志（有符号数，负数为1）</li>
<li>OF 补码溢出标志（1溢出，0不溢出）</li>
<li>TF 跟踪标志（1为单步状态，0为正常状态）</li>
<li>IF 中断标志（允许处理可屏蔽中断为1）</li>
<li>······</li>
</ul>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241653434.png" srcset="/img/loading.gif" lazyload alt="image-20230724165348353"></p>
<p>在x64架构下，原来的eflags寄存器升级为64位的rflags，不过其高32位并没有新增什么功能，保留为将来使用。</p>
<h3 id="2-3-指令寄存器"><a href="#2-3-指令寄存器" class="headerlink" title="2.3 指令寄存器"></a>2.3 指令寄存器</h3><blockquote>
<p><strong>eip</strong>: 指令寄存器可以说是CPU中最最重要的寄存器了，它指向了下一条要执行的指令所存放的地址，CPU的工作其实就是不断取出它指向的指令，然后执行这条指令，同时指令寄存器继续指向下面一条指令，如此不断重复，这就是CPU工作的基本日常。</p>
</blockquote>
<p>而在漏洞攻击中，黑客想尽办法费尽心机都想要修改指令寄存器的地址，从而能够执行恶意代码。</p>
<p>同样的，在x64架构下，32位的eip升级为64位的<strong>rip</strong>寄存器。</p>
<h3 id="2-4-段寄存器"><a href="#2-4-段寄存器" class="headerlink" title="2.4 段寄存器"></a>2.4 段寄存器</h3><p>段寄存器与CPU的内存寻址技术紧密相关。</p>
<p>早在16位的8086CPU时代，内存资源宝贵，CPU使用分段式内存寻址技术：</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241656064.png" srcset="/img/loading.gif" lazyload alt="image-20230724165637000"></p>
<p>16位的寄存器能寻址的范围是64KB，通过引入段的概念，将内存空间划分为不同的区域：分段，通过段基址+段内偏移段方式来寻址。</p>
<p>这样一来，段的基地址保存在哪里呢？8086CPU专门设置了几个段寄存器用来保存段的基地址，这就是段寄存器段的由来。</p>
<p>段寄存器也是16位的。</p>
<p>段寄存器有下面6个，前面4个是早期16位模式就引入了，到了32位时代，又新增了fs和gs两个段寄存器。</p>
<ul>
<li><strong>cs</strong>: 代码段</li>
<li><strong>ds</strong>: 数据段</li>
<li><strong>ss</strong>: 栈段</li>
<li><strong>es</strong>: 扩展段</li>
<li><strong>fs</strong>: 数据段</li>
<li><strong>gs</strong>: 数据段</li>
</ul>
<p>段寄存器里面存储的内容与CPU当前工作的内存寻址模式紧密相关。</p>
<p>当CPU处于16位实地址模式下时，段寄存器存储段的基地址，寻址时，将段寄存器内容左移4位（乘以16）得到段基地址+段内偏移得到最终的地址。</p>
<p>当CPU工作于保护模式下，段寄存器存储的内容不再是段基址了，此时的段寄存器中存放的是<strong>段选择子</strong>，用来指示当前这个段寄存器“指向”的是哪个分段。</p>
<p>注意我这里的指向打了引号，段寄存器中存储的并不是内存段的直接地址，而是段选择子，它的结构如下：</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241657443.png" srcset="/img/loading.gif" lazyload alt="image-20230724165705393"></p>
<p>16个bit长度的段寄存器内容划分了三个字段：</p>
<ul>
<li><strong>PRL</strong>: 特权请求级，就是我们常说的ring0-ring3四个特权级。</li>
<li><strong>TI</strong>: 0表示用的是全局描述符表GDT，1表示使用的是局部描述符表LDT。</li>
<li><strong>Index</strong>: 这是一个表格中表项的索引值，这个表格叫<strong>内存描述符表</strong>，它的每一个表项都描述了一个内存分段。</li>
</ul>
<p>这里提到了两个表，全局描述符表GDT和局部描述符表LDT，关于这两个表的介绍，下面介绍描述符寄存器时再详述，这里只需要知道，这是CPU支持分段式内存管理需要的表格，放在内存中，表格中的每一项都是一个描述符，记录了一个内存分段的信息。</p>
<p>保护模式下的段寄存器和段描述符到最后的内存分段，通过下图的方式联系在一起：</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241658819.png" srcset="/img/loading.gif" lazyload alt="image-20230724165837724"></p>
<p>通用寄存器、段寄存器、标志寄存器、指令寄存器，这四组寄存器共同构成了一个基本的指令执行环境，一个线程的上下文也基本上就是这些寄存器，在执行线程切换的时候，就是修改它们的内容。</p>
<h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>控制寄存器是CPU中一组相当重要的寄存器，我们知道eflags寄存器记录了当前运行线程的一系列关键信息。</p>
<p>那CPU运行过程中自身的一些关键信息保存在哪里呢？答案是控制寄存器！</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241659028.png" srcset="/img/loading.gif" lazyload alt="image-20230724165946931"></p>
<p>32位CPU总共有cr0-cr4共5个控制寄存器，64位增加了cr8。他们各自有不同的功能，但都存储了CPU工作时的重要信息：</p>
<ul>
<li><strong>cr0</strong>: 存储了CPU控制标记和工作状态</li>
<li><strong>cr1</strong>: 保留未使用</li>
<li><strong>cr2</strong>: 页错误出现时保存导致出错的地址</li>
<li><strong>cr3</strong>: 存储了当前进程的虚拟地址空间的重要信息——<strong>页目录</strong>地址</li>
<li><strong>cr4</strong>: 也存储了CPU工作相关以及当前人任务的一些信息</li>
<li><strong>cr8</strong>: 64位新增扩展使用</li>
</ul>
<p>其中，CR0尤其重要，它包含了太多重要的CPU信息，值得单独关注一下：</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241701514.png" srcset="/img/loading.gif" lazyload alt="image-20230724170117455"></p>
<p>一些重要的标记位含义如下：</p>
<p><code>PG</code>: 是否启用内存分页</p>
<p><code>AM</code>: 是否启用内存对齐自动检查</p>
<p><code>WP</code>: 是否开启内存写保护，若开启，对只读页面尝试写入时将触发异常，这一机制常常被用来实现<strong>写时复制</strong>功能</p>
<p><code>PE</code>: 是否开启保护模式</p>
<p>除了CR0，另一个值得关注的寄存器是CR3，它保存了当前进程所使用的虚拟地址空间的页目录地址，可以说是整个虚拟地址翻译中的顶级指挥棒，在进程空间切换的时候，CR3也将同步切换。</p>
<h2 id="调试寄存器"><a href="#调试寄存器" class="headerlink" title="调试寄存器"></a>调试寄存器</h2><p>在x86&#x2F;x64CPU内部，还有一组用于支持软件调试的寄存器。</p>
<p>调试，对于我们程序员是家常便饭，必备技能。但你想过你的程序能够被调试背后的原理吗？</p>
<p>程序能够被调试，关键在于能够被中断执行和恢复执行，被中断的地方就是我们设置的断点。那程序是如何能在遇到断点的时候停下来呢？</p>
<p>对于一些解释执行（PHP、Python、JavaScript）或虚拟机执行（Java）的高级语言，这很容易办到，因为它们的执行都在解释器&#x2F;虚拟机的掌控之中。</p>
<p>而对于像C、C++这样的“底层”编程语言，程序代码是直接编译成CPU的机器指令来执行的，这就需要CPU来提供对于调试的支持了。</p>
<p>对于通常的断点，也就是程序执行到某个位置下就停下来，这种断点实现的方式，在x86&#x2F;x64上，是利用了一条<strong>软中断</strong>指令：<strong>int 3</strong>来进行实现的。</p>
<p>注意，这里的<strong>int</strong>不是指高级语言里面的整数，而是表示interrupt中断的意思，是一条汇编指令，int 3则表示中断向量号为3的中断。</p>
<p>在我们使用调试器下断点时，调试器将会把对应位置的原来的指令替换为一个int 3指令，机器码为0xCC。这个动作对我们是透明的，我们在调试器中看到的依然是原来的指令，但实际上内存中已经不是原来的指令了。</p>
<p>顺便提一句，两个0xCC是汉字【烫】的编码，在一些编译器里，会给线程的栈中填充大量的0xCC，如果程序出错的时候，我们经常会看到很多<strong>烫烫烫</strong>出现，就是这个原因。</p>
<p>言归正传，CPU在执行这条int 3指令时，将自动触发中断处理流程（虽然这实际上不是一个真正的中断），CPU将取出IDTR寄存器指向的中断描述符表IDT的第3项，执行里面的中断处理函数。</p>
<p>而这个中断描述符表，早在操作系统启动之初，就已经提前安排好了，所以执行这条指令后，操作系统的中断处理函数将介入，来处理这一事件。</p>
<p>后面的过程就多了，简单来说，操作系统会把触发这一事件的进程冻结起来，随后将这一事件发送到调试器，调试器拿到之后就知道目标进程触发断点了。这个时候，咱们程序员就能通过调试器的UI交互界面或者命令行调试接口来调试目标进程，查看堆栈、查看内存、变量都随你。</p>
<p>如果我们要继续运行，调试器将会把之前修改的int 3指令给恢复回去，然后告知操作系统：我处理完了，把目标进程解冻吧！</p>
<p>上面简单描述了一下普通断点的实现原理。现在思考一个场景：我们发现一个bug，某个全局整数型变量的值老是莫名其妙被修改，但你发现有很多线程，很多函数都有可能会去修改这个变量，你想找出到底谁干的，怎么办？</p>
<p>这个时候上面的普通断点就没办法了，你需要一种新的断点：<strong>硬件断点</strong>。</p>
<p>这时候就该调试寄存器登场表演了。</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241703503.png" srcset="/img/loading.gif" lazyload alt="image-20230724170358424"></p>
<p>在x86架构CPU内部，提供了8个调试寄存器DR0~DR7。</p>
<p><strong>DR0~DR3</strong>：这是四个用于存储地址的寄存器</p>
<p><strong>DR4~DR5</strong>：这两个有点特殊，受前面提到的CR4寄存器中的标志位DE位控制，如果CR4的DE位是1，则DR4、DR5是不可访问的，访问将触发异常。如果CR4的DE位是0，则DR4和DR5将会变成DR6和DR7的别名，相当于做了一个软链接。这样做是为了将DR4、DR5保留，以便将来扩展调试功能时使用。</p>
<p><strong>DR6</strong>：这个寄存器中存储了硬件断点触发后的一些状态信息</p>
<p><strong>DR7</strong>：调试控制寄存器，这里面记录了对DR0-DR3这四个寄存器中存储地址的中断方式（是对地址的读，还是写，还是执行）、数据长度（1&#x2F;2&#x2F;4个字节）以及作用范围等信息</p>
<p>通过调试器的接口设置硬件断点后，CPU在执行代码的过程中，如果满足条件，将自动中断下来。</p>
<p>回答前面提出的问题，想要找出是谁偷偷修改了全局整形变量，只需要通过调试器设置一个硬件写入断点即可。</p>
<h3 id="描述符寄存器"><a href="#描述符寄存器" class="headerlink" title="描述符寄存器"></a>描述符寄存器</h3><p>所谓<strong>描述符</strong>，其实就是一个数据结构，用来记录一些信息，‘描述’一个东西。把很多个描述符排列在一起，组成一个表，就成了描述符表。再使用一个寄存器来指向这个表，这个寄存器就是<strong>描述符寄存器</strong>。</p>
<p>在x86&#x2F;x64系列CPU中，有三个非常重要的描述符寄存器，它们分别存储了三个地址，指向了三个非常重要的描述符表。</p>
<p><code>gdtr</code>: 全局描述符表寄存器，前面提到，CPU现在使用的是段+分页结合的内存管理方式，那系统总共有那些分段呢？这就存储在一个叫全局描述符表（<strong>GDT</strong>）的表格中，并用gdtr寄存器指向这个表。这个表中的每一项都描述了一个内存段的信息。</p>
<p><code>ldtr</code>: 局部描述符表寄存器，这个寄存器和上面的gdtr一样，同样指向的是一个段描述符表（<strong>LDT</strong>）。不同的是，GDT是全局唯一，LDT是局部使用的，可以创建多个，随着任务段切换而切换（下文介绍任务寄存器会提到）。</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241704250.png" srcset="/img/loading.gif" lazyload alt="image-20230724170435177"></p>
<p>GDT和LDT中的表项，就是段描述符，描述了一个内存分段的信息，其结构如下：</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241704111.png" srcset="/img/loading.gif" lazyload alt="image-20230724170448034"></p>
<p>一个表项占据8个字节（32位CPU），里面存储了一个内存分段的诸多信息：基地址、大小、权限、类型等信息。</p>
<p>除了这两个段描述符寄存器，还有一个非常重要的描述符寄存器：</p>
<p><code>idtr</code>: 中断描述符表寄存器，指向了<strong>中断描述符表IDT</strong>，这个表的每一项都是一个中断处理描述符，当CPU执行过程中发生了硬中断、异常、软中断时，将自动从这个表中定位对应的表项，里面记录了发生中断、异常时该去哪里执行处理函数。</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241705170.png" srcset="/img/loading.gif" lazyload alt="image-20230724170521092"></p>
<p>IDT中的表项称为<strong>Gate</strong>，中文意思为<strong>门</strong>，因为这是应用程序进入内核的主要入口。虽然表的名字叫中断描述符表，但表中存储的不全是中断描述符，IDT中的表项存在三种类型，对应三种类型的门：</p>
<ul>
<li><strong>任务门</strong></li>
<li><strong>陷阱门</strong></li>
<li><strong>中断门</strong></li>
</ul>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241705976.png" srcset="/img/loading.gif" lazyload alt="image-20230724170544891"></p>
<p>三种描述符中都存储了处理这个中断&#x2F;异常&#x2F;任务时该去哪里处理的地址。三种门用途不一，其中中断门是真正意义上的中断，而像前面提到的调试指令int 3以及老式的系统调用指令int 2e&#x2F;int 80都属于陷阱门。任务门则用的较少，要了解任务门，先了解下任务寄存器。</p>
<h3 id="任务寄存器"><a href="#任务寄存器" class="headerlink" title="任务寄存器"></a>任务寄存器</h3><p>现代操作系统，都是支持多任务并发运行的，x86架构CPU为了顺应时代潮流，在硬件层面上提供了专门的机制用来支持多任务的切换，这体现在两个方面：</p>
<ul>
<li>CPU内部设置了一个专用的寄存器——<strong>任务寄存器TR</strong>，它指向当前运行的任务。</li>
</ul>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241706350.png" srcset="/img/loading.gif" lazyload alt="image-20230724170626282"></p>
<p>定义了描述任务的数据结构<strong>TSS</strong>，里面存储了一个任务的上下文（一系列寄存器的值），下图是一个32位CPU的TSS结构图：</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241707552.png" srcset="/img/loading.gif" lazyload alt="image-20230724170748458"></p>
<p>x86CPU的构想是每一个任务对应一个TSS，然后由TR寄存器指向当前的任务，执行任务切换时，修改TR寄存器的指向即可，这是硬件层面的多任务切换机制。</p>
<p>这个构想其实还是很不错的，然而现实却打了脸，包括Linux和Windows在内的主流操作系统都没有使用这个机制来进行线程切换，而是自己使用软件来实现多线程切换。</p>
<p>所以，绝大多数情况下，TR寄存器都是指向固定的，即便线程切换了，TR寄存器仍然不会变化。</p>
<p>注意，我这里说的的是绝大多数情况，而没有说死。虽然操作系统不依靠TSS来实现多任务切换，但这并不意味着CPU提供的TSS操作系统一点也没有使用。还是存在一些特殊情况，如一些异常处理会使用到TSS来执行处理。</p>
<p>下面这张图，展示了控制寄存器、描述符寄存器、任务寄存器构成的全貌：</p>
<p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241708313.png" srcset="/img/loading.gif" lazyload alt="image-20230724170828192"></p>
<h3 id="模型特定寄存器"><a href="#模型特定寄存器" class="headerlink" title="模型特定寄存器"></a>模型特定寄存器</h3><p>从80486之后的x86架构CPU，内部增加了一组新的寄存器，统称为<strong>MSR寄存器</strong>，中文直译是模型特定寄存器，意思是这些寄存器不像上面列出的寄存器是固定的，这些寄存器可能随着不同的版本有所变化。这些寄存器主要用来支持一些新的功能。</p>
<p>随着x86CPU不断更新换代，MSR寄存器变的越来越多，但与此同时，有一部分MSR寄存器随着版本迭代，慢慢固化下来，成为了变化中那部分不变的，这部分MSR寄存器，Intel将其称为Architected MSR，这部分MSR寄存器，在命名上，统一加上了<strong>IA32</strong>的前缀。</p>
<p>这里选取三个代表性的MSR简单介绍一下：</p>
<ul>
<li>IA32_SYSENTER_CS</li>
<li>IA32_SYSENTER_ESP</li>
<li>IA32_SYSENTER_EIP</li>
</ul>
<p>这三个MSR寄存器是用来实现<strong>快速系统调用</strong>。</p>
<p>在早期的x86架构CPU上，系统调用依赖于软中断实现，类似于前面调试用到的int 3指令，在Windows上，系统调用用到的是<strong>int 2e</strong>，在Linux上，用的是<strong>int 80</strong>。</p>
<p>软中断毕竟还是比较慢的，因为执行软中断就需要内存查表，通过IDTR定位到IDT，再取出函数进行执行。</p>
<p>系统调用是一个频繁触发的动作，如此这般势必对性能有所影响。在进入奔腾时代后，就加上了上面的三个MSR寄存器，分别存储了执行系统调用后，内核系统调用入口函数所需要的段寄存器、堆栈栈顶、函数地址，不再需要内存查表。快速系统调用还提供了专门的CPU指令<strong>sysenter&#x2F;sysexit</strong>用来发起系统调用和退出系统调用。</p>
<p>在64位上，这一对指令升级为<strong>syscall&#x2F;sysret</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是全部要介绍的寄存器了，需要说明一下的是，这并不是x86CPU全部所有的寄存器，除了这些，还存在XMM、MMX、FPU浮点数运算等其他寄存器。</p>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://shell-storm.org/x86doc/">Intel x86 Opcode Table and Reference (shell-storm.org)</a></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">---------- 一、数据传输指令 ----------------------------------------------------  <br>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.  <br><span class="hljs-number">1</span>. 通用数据传送指令.  <br>    <span class="hljs-keyword">MOV</span>     传送字或字节.  <br>    <span class="hljs-keyword">MOVSX</span>   先符号扩展,再传送.  <br>    <span class="hljs-keyword">MOVZX</span>   先零扩展,再传送.  <br>    <span class="hljs-keyword">PUSH</span>    把字压入堆栈.  <br>    <span class="hljs-keyword">POP</span>     把字弹出堆栈.  <br>    <span class="hljs-keyword">PUSHA</span>   把<span class="hljs-built_in">AX</span>,<span class="hljs-built_in">CX</span>,<span class="hljs-built_in">DX</span>,<span class="hljs-built_in">BX</span>,<span class="hljs-built_in">SP</span>,<span class="hljs-built_in">BP</span>,<span class="hljs-built_in">SI</span>,<span class="hljs-built_in">DI</span>依次压入堆栈.  <br>    <span class="hljs-keyword">POPA</span>    把<span class="hljs-built_in">DI</span>,<span class="hljs-built_in">SI</span>,<span class="hljs-built_in">BP</span>,<span class="hljs-built_in">SP</span>,<span class="hljs-built_in">BX</span>,<span class="hljs-built_in">DX</span>,<span class="hljs-built_in">CX</span>,<span class="hljs-built_in">AX</span>依次弹出堆栈.  <br>    <span class="hljs-keyword">PUSHAD</span>  把<span class="hljs-built_in">EAX</span>,<span class="hljs-built_in">ECX</span>,<span class="hljs-built_in">EDX</span>,<span class="hljs-built_in">EBX</span>,<span class="hljs-built_in">ESP</span>,<span class="hljs-built_in">EBP</span>,<span class="hljs-built_in">ESI</span>,<span class="hljs-built_in">EDI</span>依次压入堆栈.  <br>    <span class="hljs-keyword">POPAD</span>   把<span class="hljs-built_in">EDI</span>,<span class="hljs-built_in">ESI</span>,<span class="hljs-built_in">EBP</span>,<span class="hljs-built_in">ESP</span>,<span class="hljs-built_in">EBX</span>,<span class="hljs-built_in">EDX</span>,<span class="hljs-built_in">ECX</span>,<span class="hljs-built_in">EAX</span>依次弹出堆栈.  <br>    <span class="hljs-keyword">BSWAP</span>   交换<span class="hljs-number">32</span>位寄存器里字节的顺序  <br>    <span class="hljs-keyword">XCHG</span>    交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数)  <br>    <span class="hljs-keyword">CMPXCHG</span> 比较并交换操作数.(第二个操作数必须为累加器<span class="hljs-built_in">AL</span>/<span class="hljs-built_in">AX</span>/<span class="hljs-built_in">EAX</span>)  <br>    <span class="hljs-keyword">XADD</span>    先交换再累加.(结果在第一个操作数里)  <br>    <span class="hljs-keyword">XLAT</span>    字节查表转换.----<span class="hljs-built_in">BX</span>指向一张<span class="hljs-number">256</span>字节的表的起点,<span class="hljs-built_in">AL</span>为表的索引值(<span class="hljs-number">0</span>-<span class="hljs-number">255</span>,即<span class="hljs-number">0</span>-<span class="hljs-number">FFH</span>)<span class="hljs-comment">;返回AL为查表结果.([BX+AL]-&gt;AL)  </span><br><span class="hljs-number">2</span>. 输入输出端口传送指令.  <br>    <span class="hljs-keyword">IN</span>      I/O端口输入. ( 语法: <span class="hljs-keyword">IN</span>   累加器,    &#123;端口号│<span class="hljs-built_in">DX</span>&#125; )  <br>    <span class="hljs-keyword">OUT</span>     I/O端口输出. ( 语法: <span class="hljs-keyword">OUT</span> &#123;端口号│<span class="hljs-built_in">DX</span>&#125;,累加器 )输入输出端口由立即方式指定时,    其范围是 <span class="hljs-number">0</span>-<span class="hljs-number">255</span><span class="hljs-comment">; 由寄存器 DX 指定时,其范围是    0-65535.  </span><br><span class="hljs-number">3</span>. 目的地址传送指令.  <br>    <span class="hljs-keyword">LEA</span>     装入有效地址.例: <span class="hljs-keyword">LEA</span> <span class="hljs-built_in">DX</span>,string <span class="hljs-comment">;把偏移地址存到DX.  </span><br>    <span class="hljs-keyword">LDS</span>     传送目标指针,把指针内容装入<span class="hljs-built_in">DS</span>.例: <span class="hljs-keyword">LDS</span> <span class="hljs-built_in">SI</span>,string   <span class="hljs-comment">;把段地址:偏移地址存到DS:SI.  </span><br>    <span class="hljs-keyword">LES</span>     传送目标指针,把指针内容装入<span class="hljs-built_in">ES</span>.例: <span class="hljs-keyword">LES</span> <span class="hljs-built_in">DI</span>,string   <span class="hljs-comment">;把段地址:偏移地址存到ES:DI.  </span><br>    <span class="hljs-keyword">LFS</span>     传送目标指针,把指针内容装入<span class="hljs-built_in">FS</span>.例: <span class="hljs-keyword">LFS</span> <span class="hljs-built_in">DI</span>,string   <span class="hljs-comment">;把段地址:偏移地址存到FS:DI.  </span><br>    <span class="hljs-keyword">LGS</span>     传送目标指针,把指针内容装入<span class="hljs-built_in">GS</span>.例: <span class="hljs-keyword">LGS</span> <span class="hljs-built_in">DI</span>,string   <span class="hljs-comment">;把段地址:偏移地址存到GS:DI.  </span><br>    <span class="hljs-keyword">LSS</span>     传送目标指针,把指针内容装入<span class="hljs-built_in">SS</span>.例: <span class="hljs-keyword">LSS</span> <span class="hljs-built_in">DI</span>,string   <span class="hljs-comment">;把段地址:偏移地址存到SS:DI.  </span><br><span class="hljs-number">4</span>. 标志传送指令.  <br>    <span class="hljs-keyword">LAHF</span>    标志寄存器传送,把标志装入<span class="hljs-number">AH</span>.  <br>    <span class="hljs-keyword">SAHF</span>    标志寄存器传送,把<span class="hljs-number">AH</span>内容装入标志寄存器.  <br>    <span class="hljs-keyword">PUSHF</span>   标志入栈.  <br>    <span class="hljs-keyword">POPF</span>    标志出栈.  <br>    PUSHD   <span class="hljs-number">32</span>位标志入栈.  <br>    POPD    <span class="hljs-number">32</span>位标志出栈.  <br>---------- 二、算术运算指令 ----------------------------------------------------  <br>    <span class="hljs-keyword">ADD</span>     加法.  <br>    <span class="hljs-keyword">ADC</span>     带进位加法.  <br>    <span class="hljs-keyword">INC</span>     加 <span class="hljs-number">1</span>.  <br>    <span class="hljs-keyword">AAA</span>     加法的ASCII码调整.  <br>    <span class="hljs-keyword">DAA</span>     加法的十进制调整.  <br>    <span class="hljs-keyword">SUB</span>     减法.  <br>    <span class="hljs-keyword">SBB</span>     带借位减法.  <br>    <span class="hljs-keyword">DEC</span>     减 <span class="hljs-number">1</span>.  <br>    <span class="hljs-keyword">NEG</span>     求反(以<span class="hljs-number">0</span> 减之).  <br>    <span class="hljs-keyword">CMP</span>     比较.(两操作数作减法,仅修改标志位,不回送结果，相同为<span class="hljs-number">1</span>).  <br>    <span class="hljs-keyword">AAS</span>     减法的ASCII码调整.  <br>    <span class="hljs-keyword">DAS</span>     减法的十进制调整.  <br>    <span class="hljs-keyword">MUL</span>     无符号乘法.结果回送<span class="hljs-number">AH</span>和<span class="hljs-built_in">AL</span>(字节运算),或<span class="hljs-built_in">DX</span>和<span class="hljs-built_in">AX</span>(字运算),  <br>    <span class="hljs-keyword">IMUL</span>    整数乘法.结果回送<span class="hljs-number">AH</span>和<span class="hljs-built_in">AL</span>(字节运算),或<span class="hljs-built_in">DX</span>和<span class="hljs-built_in">AX</span>(字运算),  <br>    <span class="hljs-keyword">AAM</span>     乘法的ASCII码调整.  <br>    <span class="hljs-keyword">DIV</span>     无符号除法.结果回送:商回送<span class="hljs-built_in">AL</span>,余数回送<span class="hljs-number">AH</span>, (字节运算)<span class="hljs-comment">;或 商回送AX,余数回送DX, (字运算).  </span><br>    <span class="hljs-keyword">IDIV</span>    整数除法.结果回送:商回送<span class="hljs-built_in">AL</span>,余数回送<span class="hljs-number">AH</span>, (字节运算)<span class="hljs-comment">;或 商回送AX,余数回送DX, (字运算).  </span><br>    <span class="hljs-keyword">AAD</span>     除法的ASCII码调整.  <br>    <span class="hljs-keyword">CBW</span>     字节转换为字. (把<span class="hljs-built_in">AL</span>中字节的符号扩展到<span class="hljs-number">AH</span>中去)  <br>    <span class="hljs-keyword">CWD</span>     字转换为双字. (把<span class="hljs-built_in">AX</span>中的字的符号扩展到<span class="hljs-built_in">DX</span>中去)  <br>    <span class="hljs-keyword">CWDE</span>    字转换为双字. (把<span class="hljs-built_in">AX</span>中的字符号扩展到<span class="hljs-built_in">EAX</span>中去)  <br>    <span class="hljs-keyword">CDQ</span>     双字扩展. (把<span class="hljs-built_in">EAX</span>中的字的符号扩展到<span class="hljs-built_in">EDX</span>中去)  <br>---------- 三、逻辑运算指令 ----------------------------------------------------  <br>    <span class="hljs-keyword">AND</span>     与运算.  <br>    <span class="hljs-keyword">OR</span>      或运算.  <br>    <span class="hljs-keyword">XOR</span>     异或运算.  <br>    <span class="hljs-keyword">NOT</span>     取反.  <br>    <span class="hljs-keyword">TEST</span>    测试.(两操作数作与运算,仅修改标志位,不回送结果).  <br>    <span class="hljs-keyword">SHL</span>     逻辑左移.  <br>    <span class="hljs-keyword">SAL</span>     算术左移.(=<span class="hljs-keyword">SHL</span>)  <br>    <span class="hljs-keyword">SHR</span>     逻辑右移.  <br>    <span class="hljs-keyword">SAR</span>     算术右移.(=<span class="hljs-keyword">SHR</span>)  <br>    <span class="hljs-keyword">ROL</span>     循环左移.  <br>    <span class="hljs-keyword">ROR</span>     循环右移.  <br>    <span class="hljs-keyword">RCL</span>     通过进位的循环左移.  <br>    <span class="hljs-keyword">RCR</span>     通过进位的循环右移.  <br>              以上八种移位指令,其移位次数可达<span class="hljs-number">255</span>次.  <br>              移位一次时, 可直接用操作码. 如 <span class="hljs-keyword">SHL</span> <span class="hljs-built_in">AX</span>,<span class="hljs-number">1</span>.  <br>              移位&gt;<span class="hljs-number">1</span>次时, 则由寄存器<span class="hljs-built_in">CL</span>给出移位次数.  <br>              如 <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">04</span>   <span class="hljs-keyword">SHL</span> <span class="hljs-built_in">AX</span>,<span class="hljs-built_in">CL</span>  <br>---------- 四、串指令 ----------------------------------------------------------  <br><span class="hljs-symbol">              DS:</span><span class="hljs-built_in">SI</span> 源串段寄存器 :源串变址.  <br><span class="hljs-symbol">              ES:</span><span class="hljs-built_in">DI</span> 目标串段寄存器:目标串变址.  <br>              <span class="hljs-built_in">CX</span> 重复次数计数器.  <br>              <span class="hljs-built_in">AL</span>/<span class="hljs-built_in">AX</span> 扫描值.  <br>              D标志   <span class="hljs-number">0</span>表示重复操作中<span class="hljs-built_in">SI</span>和<span class="hljs-built_in">DI</span>应自动增量<span class="hljs-comment">; 1表示应自动减量.  </span><br>              Z标志   用来控制扫描或比较操作的结束.  <br>    MOVS    串传送.( <span class="hljs-keyword">MOVSB</span> 传送字符. <span class="hljs-keyword">MOVSW</span> 传送字. <span class="hljs-keyword">MOVSD</span> 传送双字. )  <br>    CMPS    串比较.( <span class="hljs-keyword">CMPSB</span> 比较字符. <span class="hljs-keyword">CMPSW</span> 比较字. )  <br>    SCAS    串扫描.把<span class="hljs-built_in">AL</span>或<span class="hljs-built_in">AX</span>的内容与目标串作比较,比较结果反映在标志位.  <br>    LODS    装入串.把源串中的元素(字或字节)逐一装入<span class="hljs-built_in">AL</span>或<span class="hljs-built_in">AX</span>中.( <span class="hljs-keyword">LODSB</span> 传送字符. <span class="hljs-keyword">LODSW</span> 传送字.    <span class="hljs-keyword">LODSD</span> 传送双字. )  <br>    STOS    保存串.是LODS的逆过程.  <br>    <span class="hljs-keyword">REP</span>         当<span class="hljs-built_in">CX</span>/<span class="hljs-built_in">ECX</span>&lt;&gt;<span class="hljs-number">0</span>时重复.  <br>    <span class="hljs-keyword">REPE</span>/<span class="hljs-keyword">REPZ</span>   当ZF=<span class="hljs-number">1</span>或比较结果相等,且<span class="hljs-built_in">CX</span>/<span class="hljs-built_in">ECX</span>&lt;&gt;<span class="hljs-number">0</span>时重复.  <br>    <span class="hljs-keyword">REPNE</span>/<span class="hljs-keyword">REPNZ</span> 当ZF=<span class="hljs-number">0</span>或比较结果不相等,且<span class="hljs-built_in">CX</span>/<span class="hljs-built_in">ECX</span>&lt;&gt;<span class="hljs-number">0</span>时重复.  <br>    REPC        当CF=<span class="hljs-number">1</span>且<span class="hljs-built_in">CX</span>/<span class="hljs-built_in">ECX</span>&lt;&gt;<span class="hljs-number">0</span>时重复.  <br>    REPNC       当CF=<span class="hljs-number">0</span>且<span class="hljs-built_in">CX</span>/<span class="hljs-built_in">ECX</span>&lt;&gt;<span class="hljs-number">0</span>时重复.  <br>---------- 五、程序转移指令 ----------------------------------------------------  <br><span class="hljs-number">1</span>. 无条件转移指令 (长转移)  <br>    <span class="hljs-keyword">JMP</span>         无条件转移指令  <br>    <span class="hljs-keyword">CALL</span>        过程调用  <br>    <span class="hljs-keyword">RET</span>/<span class="hljs-keyword">RETF</span>    过程返回.  <br><span class="hljs-number">2</span>. 条件转移指令   (短转移,-<span class="hljs-number">128</span>到+<span class="hljs-number">127</span>的距离内)( 当且仅当(SF <span class="hljs-keyword">XOR</span> OF)=<span class="hljs-number">1</span>时,OP1&lt;OP2 )  <br>    <span class="hljs-keyword">JA</span>/<span class="hljs-keyword">JNBE</span>     不小于或不等于时转移.  <br>    <span class="hljs-keyword">JAE</span>/<span class="hljs-keyword">JNB</span>     大于或等于转移.  <br>    <span class="hljs-keyword">JB</span>/<span class="hljs-keyword">JNAE</span>     小于转移.  <br>    <span class="hljs-keyword">JBE</span>/<span class="hljs-keyword">JNA</span>     小于或等于转移.  <br>        以上四条,测试无符号整数运算的结果(标志C和Z).  <br>    <span class="hljs-keyword">JG</span>/<span class="hljs-keyword">JNLE</span>     大于转移.  <br>    <span class="hljs-keyword">JGE</span>/<span class="hljs-keyword">JNL</span>     大于或等于转移.  <br>    <span class="hljs-keyword">JL</span>/<span class="hljs-keyword">JNGE</span>     小于转移.  <br>    <span class="hljs-keyword">JLE</span>/<span class="hljs-keyword">JNG</span>     小于或等于转移.  <br>        以上四条,测试带符号整数运算的结果(标志S,O和Z).  <br>    <span class="hljs-keyword">JE</span>/<span class="hljs-keyword">JZ</span>       等于转移.  <br>    <span class="hljs-keyword">JNE</span>/<span class="hljs-keyword">JNZ</span>     不等于时转移.  <br>    <span class="hljs-keyword">JC</span>          有进位时转移.  <br>    <span class="hljs-keyword">JNC</span>         无进位时转移.  <br>    <span class="hljs-keyword">JNO</span>         不溢出时转移.  <br>    <span class="hljs-keyword">JNP</span>/<span class="hljs-keyword">JPO</span>     奇偶性为奇数时转移.  <br>    <span class="hljs-keyword">JNS</span>         符号位为 <span class="hljs-string">&quot;0&quot;</span> 时转移.  <br>    <span class="hljs-keyword">JO</span>          溢出转移.  <br>    <span class="hljs-keyword">JP</span>/<span class="hljs-keyword">JPE</span>      奇偶性为偶数时转移.  <br>    <span class="hljs-keyword">JS</span>          符号位为 <span class="hljs-string">&quot;1&quot;</span> 时转移.  <br><span class="hljs-number">3</span>. 循环控制指令(短转移)  <br>    <span class="hljs-keyword">LOOP</span>            <span class="hljs-built_in">CX</span>不为零时循环.  <br>    <span class="hljs-keyword">LOOPE</span>/<span class="hljs-keyword">LOOPZ</span>     <span class="hljs-built_in">CX</span>不为零且标志Z=<span class="hljs-number">1</span>时循环.  <br>    <span class="hljs-keyword">LOOPNE</span>/<span class="hljs-keyword">LOOPNZ</span>   <span class="hljs-built_in">CX</span>不为零且标志Z=<span class="hljs-number">0</span>时循环.  <br>    <span class="hljs-keyword">JCXZ</span>            <span class="hljs-built_in">CX</span>为零时转移.  <br>    <span class="hljs-keyword">JECXZ</span>           <span class="hljs-built_in">ECX</span>为零时转移.  <br><span class="hljs-number">4</span>. 中断指令  <br>    <span class="hljs-keyword">INT</span>         中断指令  <br>    <span class="hljs-keyword">INTO</span>        溢出中断  <br>    <span class="hljs-keyword">IRET</span>        中断返回  <br><span class="hljs-number">5</span>. 处理器控制指令  <br>    <span class="hljs-keyword">HLT</span>         处理器暂停,  直到出现中断或复位信号才继续.  <br>    WAIT        当芯片引线<span class="hljs-keyword">TEST</span>为高电平时使<span class="hljs-meta">CPU</span>进入等待状态.  <br>    ESC         转换到外处理器.  <br>    <span class="hljs-keyword">LOCK</span>        封锁总线.  <br>    <span class="hljs-keyword">NOP</span>         空操作.  <br>    <span class="hljs-keyword">STC</span>         置进位标志位.  <br>    <span class="hljs-keyword">CLC</span>         清进位标志位.  <br>    <span class="hljs-keyword">CMC</span>         进位标志取反.  <br>    <span class="hljs-keyword">STD</span>         置方向标志位.  <br>    <span class="hljs-keyword">CLD</span>         清方向标志位.  <br>    <span class="hljs-keyword">STI</span>         置中断允许位.  <br>    <span class="hljs-keyword">CLI</span>         清中断允许位.  <br>---------- 六、伪指令 ----------------------------------------------------------  <br>    <span class="hljs-built_in">DW</span>          定义字(<span class="hljs-number">2</span>字节).  <br>    PROC        定义过程.  <br>    ENDP        过程结束.  <br>    <span class="hljs-meta">SEGMENT</span>     定义段.  <br>    <span class="hljs-meta">ASSUME</span>      建立段寄存器寻址.  <br>    ENDS        段结束.  <br>    END         程序结束.  <br>---------- 七、处理机控制指令：标志处理指令 ------------------------------------  <br>    <span class="hljs-keyword">CLC</span>     进位位置<span class="hljs-number">0</span>指令  <br>    <span class="hljs-keyword">CMC</span>     进位位求反指令  <br>    <span class="hljs-keyword">STC</span>     进位位置为<span class="hljs-number">1</span>指令  <br>    <span class="hljs-keyword">CLD</span>     方向标志置<span class="hljs-number">1</span>指令  <br>    <span class="hljs-keyword">STD</span>     方向标志位置<span class="hljs-number">1</span>指令  <br>    <span class="hljs-keyword">CLI</span>     中断标志置<span class="hljs-number">0</span>指令  <br>    <span class="hljs-keyword">STI</span>     中断标志置<span class="hljs-number">1</span>指令  <br>    <span class="hljs-keyword">NOP</span>     无操作  <br>    <span class="hljs-keyword">HLT</span>     停机  <br>    WAIT    等待  <br>    ESC     换码  <br>    <span class="hljs-keyword">LOCK</span>    封锁  <br>========== 浮点运算指令集 ======================================================  <br>---------- 一、控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)----  <br><span class="hljs-keyword">FINIT</span>                 初始化浮点部件                  机器码  9B <span class="hljs-built_in">DB</span> E3  <br><span class="hljs-keyword">FCLEX</span>                 清除异常                         机器码  9B <span class="hljs-built_in">DB</span> E2  <br><span class="hljs-keyword">FDISI</span>                 浮点检查禁止中断                 机器码  9B <span class="hljs-built_in">DB</span> E1  <br><span class="hljs-keyword">FENI</span>                  浮点检查禁止中断二            机器码  9B <span class="hljs-built_in">DB</span> E0  <br>WAIT                  同步<span class="hljs-meta">CPU</span>和FPU                    机器码  9B  <br><span class="hljs-keyword">FWAIT</span>                 同步<span class="hljs-meta">CPU</span>和FPU                    机器码  D9 D0  <br><span class="hljs-keyword">FNOP</span>                  无操作                          机器码  DA E9  <br><span class="hljs-keyword">FXCH</span>                  交换<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)和<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)                机器码  D9 C9  <br><span class="hljs-keyword">FXCH</span> <span class="hljs-built_in">ST</span>(i)            交换<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)和<span class="hljs-built_in">ST</span>(i)                机器码  D9 C1iii  <br><span class="hljs-keyword">FSTSW</span> <span class="hljs-built_in">ax</span>              状态字到<span class="hljs-built_in">ax</span>                       机器码  9B DF E0  <br><span class="hljs-keyword">FSTSW</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  状态字到mem                      机器码  9B <span class="hljs-built_in">DD</span> mm111mmm  <br><span class="hljs-keyword">FLDCW</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  mem到状态字                      机器码  D9 mm101mmm  <br><span class="hljs-keyword">FSTCW</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  控制字到mem                      机器码  9B D9 mm111mmm  <br>  <br><span class="hljs-keyword">FLDENV</span>  <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  mem到全环境                      机器码  D9 mm100mmm  <br><span class="hljs-keyword">FSTENV</span>  <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  全环境到mem                      机器码  9B D9 mm110mmm  <br><span class="hljs-keyword">FRSTOR</span>  <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  mem到FPU状态                    机器码  <span class="hljs-built_in">DD</span> mm100mmm  <br><span class="hljs-keyword">FSAVE</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  FPU状态到mem                    机器码  9B <span class="hljs-built_in">DD</span> mm110mmm  <br>  <br><span class="hljs-keyword">FFREE</span> <span class="hljs-built_in">ST</span>(i)           标志<span class="hljs-built_in">ST</span>(i)未使用                   机器码  <span class="hljs-built_in">DD</span> C0iii  <br><span class="hljs-keyword">FDECSTP</span>               减少栈指针<span class="hljs-number">1</span>-&gt;<span class="hljs-number">0</span> <span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>             机器码  D9 F6  <br><span class="hljs-keyword">FINCSTP</span>               增加栈指针<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span> <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>             机器码  D9 F7  <br><span class="hljs-keyword">FSETPM</span>                浮点设置保护                       机器码  <span class="hljs-built_in">DB</span> E4  <br>---------- 二、数据传送指令 ----------------------------------------------------  <br><span class="hljs-keyword">FLDZ</span>                  将<span class="hljs-number">0.0</span>装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)                  机器码  D9 EE  <br><span class="hljs-keyword">FLD1</span>                  将<span class="hljs-number">1.0</span>装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)                  机器码  D9 E8  <br><span class="hljs-keyword">FLDPI</span>                 将π装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)                    机器码  D9 EB  <br><span class="hljs-keyword">FLDL2T</span>                将ln10/ln2装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)             机器码  D9 E9  <br><span class="hljs-keyword">FLDL2E</span>                将<span class="hljs-number">1</span>/ln2装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)                机器码  D9 EA  <br><span class="hljs-keyword">FLDLG2</span>                将ln2/ln10装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)             机器码  D9 EC  <br><span class="hljs-keyword">FLDLN2</span>                将ln2装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)                  机器码  D9 ED  <br>  <br><span class="hljs-keyword">FLD</span>    real4 <span class="hljs-built_in">ptr</span> mem  装入mem的单精度浮点数             机器码  D9 mm000mmm  <br><span class="hljs-keyword">FLD</span>    real8 <span class="hljs-built_in">ptr</span> mem  装入mem的双精度浮点数             机器码  <span class="hljs-built_in">DD</span> mm000mmm  <br><span class="hljs-keyword">FLD</span>   real10 <span class="hljs-built_in">ptr</span> mem  装入mem的十字节浮点数             机器码  <span class="hljs-built_in">DB</span> mm101mmm  <br>  <br><span class="hljs-keyword">FILD</span>    <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  装入mem的二字节整数              机器码  DF mm000mmm  <br><span class="hljs-keyword">FILD</span>   <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> mem  装入mem的四字节整数              机器码  <span class="hljs-built_in">DB</span> mm000mmm  <br><span class="hljs-keyword">FILD</span>   <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> mem  装入mem的八字节整数              机器码  DF mm101mmm  <br>  <br><span class="hljs-keyword">FBLD</span>   tbyte <span class="hljs-built_in">ptr</span> mem  装入mem的十字节BCD数            机器码  DF mm100mmm  <br>  <br><span class="hljs-keyword">FST</span>    real4 <span class="hljs-built_in">ptr</span> mem  保存单精度浮点数到mem             机器码  D9 mm010mmm  <br><span class="hljs-keyword">FST</span>    real8 <span class="hljs-built_in">ptr</span> mem  保存双精度浮点数到mem             机器码  <span class="hljs-built_in">DD</span> mm010mmm  <br>  <br><span class="hljs-keyword">FIST</span>    <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  保存二字节整数到mem              机器码  DF mm010mmm  <br><span class="hljs-keyword">FIST</span>   <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> mem  保存四字节整数到mem              机器码  <span class="hljs-built_in">DB</span> mm010mmm  <br>  <br><span class="hljs-keyword">FSTP</span>   real4 <span class="hljs-built_in">ptr</span> mem  保存单精度浮点数到mem并出栈      机器码  D9 mm011mmm  <br><span class="hljs-keyword">FSTP</span>   real8 <span class="hljs-built_in">ptr</span> mem  保存双精度浮点数到mem并出栈      机器码  <span class="hljs-built_in">DD</span> mm011mmm  <br><span class="hljs-keyword">FSTP</span>  real10 <span class="hljs-built_in">ptr</span> mem  保存十字节浮点数到mem并出栈      机器码  <span class="hljs-built_in">DB</span> mm111mmm  <br>  <br><span class="hljs-keyword">FISTP</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  保存二字节整数到mem并出栈           机器码  DF mm011mmm  <br><span class="hljs-keyword">FISTP</span>  <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> mem  保存四字节整数到mem并出栈           机器码  <span class="hljs-built_in">DB</span> mm011mmm  <br><span class="hljs-keyword">FISTP</span>  <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> mem  保存八字节整数到mem并出栈           机器码  DF mm111mmm  <br>  <br><span class="hljs-keyword">FBSTP</span>  tbyte <span class="hljs-built_in">ptr</span> mem  保存十字节BCD数到mem并出栈     机器码  DF mm110mmm  <br>  <br><span class="hljs-keyword">FCMOVB</span>                <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) &lt;时传送              机器码  DA C0iii  <br><span class="hljs-keyword">FCMOVBE</span>               <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) &lt;=时传送             机器码  DA D0iii  <br><span class="hljs-keyword">FCMOVE</span>                <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) =时传送             机器码  DA C1iii  <br><span class="hljs-keyword">FCMOVNB</span>               <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) &gt;=时传送             机器码  <span class="hljs-built_in">DB</span> C0iii  <br><span class="hljs-keyword">FCMOVNBE</span>              <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) &gt;时传送              机器码  <span class="hljs-built_in">DB</span> D0iii  <br><span class="hljs-keyword">FCMOVNE</span>               <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) !=时传送            机器码  <span class="hljs-built_in">DB</span> C1iii  <br><span class="hljs-keyword">FCMOVNU</span>               <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) 有序时传送        机器码  <span class="hljs-built_in">DB</span> D1iii  <br><span class="hljs-keyword">FCMOVU</span>                <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) 无序时传送        机器码  DA D1iii  <br>---------- 三、比较指令   --------------------------------------------------------  <br><span class="hljs-keyword">FCOM</span>                  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)                      机器码  D8 D1  <br><span class="hljs-keyword">FCOMI</span>                 <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i)  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)         机器码  <span class="hljs-built_in">DB</span> F0iii  <br><span class="hljs-keyword">FCOMIP</span>                <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i)  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)并出栈   机器码  DF F0iii  <br><span class="hljs-keyword">FCOM</span>   real4 <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-实数mem                      机器码  D8 mm010mmm  <br><span class="hljs-keyword">FCOM</span>   real8 <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-实数mem                      机器码  DC mm010mmm  <br>  <br><span class="hljs-keyword">FICOM</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-整数mem                      机器码  DE mm010mmm  <br><span class="hljs-keyword">FICOM</span>  <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-整数mem                      机器码  DA mm010mmm  <br><span class="hljs-keyword">FICOMP</span>  <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-整数mem并出栈               机器码  DE mm011mmm  <br><span class="hljs-keyword">FICOMP</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-整数mem并出栈               机器码  DA mm011mmm  <br>  <br><span class="hljs-keyword">FTST</span>                  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-number">0</span>                          机器码  D9 E4  <br><span class="hljs-keyword">FUCOM</span>  <span class="hljs-built_in">ST</span>(i)          <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(i)                      机器码  <span class="hljs-built_in">DD</span> E0iii  <br><span class="hljs-keyword">FUCOMP</span> <span class="hljs-built_in">ST</span>(i)          <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(i)并出栈                   机器码  <span class="hljs-built_in">DD</span> E1iii  <br><span class="hljs-keyword">FUCOMPP</span>               <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)并二次出栈             机器码  DA E9  <br><span class="hljs-keyword">FXAM</span>                  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)规格类型                    机器码  D9 E5  <br>---------- 四、运算指令   --------------------------------------------------------  <br><span class="hljs-keyword">FADD</span>                  把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器)  相加，并将结果存入目的操作数  <br><span class="hljs-keyword">FADDP</span>  <span class="hljs-built_in">ST</span>(i),<span class="hljs-built_in">ST</span>       这个指令是使目的操作数加上 <span class="hljs-built_in">ST</span>  缓存器，并弹出 <span class="hljs-built_in">ST</span> 缓存器，而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了  <br><span class="hljs-keyword">FIADD</span>                 <span class="hljs-keyword">FIADD</span> 是把 <span class="hljs-built_in">ST</span>   加上来源操作数，然后再存入 <span class="hljs-built_in">ST</span> 缓存器，来源操作数必须是字组整数或短整数形态的变数  <br>  <br><span class="hljs-keyword">FSUB</span>                  减  <br><span class="hljs-keyword">FSUBP</span>  <br><span class="hljs-keyword">FSUBR</span>                 减数与被减数互换  <br><span class="hljs-keyword">FSUBRP</span>  <br><span class="hljs-keyword">FISUB</span>  <br><span class="hljs-keyword">FISUBR</span>  <br>  <br><span class="hljs-keyword">FMUL</span>                  乘  <br><span class="hljs-keyword">FMULP</span>  <br><span class="hljs-keyword">FIMUL</span>  <br>  <br><span class="hljs-keyword">FDIV</span>                  除  <br><span class="hljs-keyword">FDIVP</span>  <br><span class="hljs-keyword">FDIVR</span>  <br><span class="hljs-keyword">FDIVRP</span>  <br><span class="hljs-keyword">FIDIV</span>  <br><span class="hljs-keyword">FIDIVR</span>  <br>  <br><span class="hljs-keyword">FCHS</span>                  改变 <span class="hljs-built_in">ST</span> 的正负值  <br>  <br><span class="hljs-keyword">FABS</span>                  把 <span class="hljs-built_in">ST</span>  之值取出，取其绝对值后再存回去。  <br>  <br><span class="hljs-keyword">FSQRT</span>                 将 <span class="hljs-built_in">ST</span>  之值取出，开根号后再存回去。  <br>  <br><span class="hljs-keyword">FSCALE</span>                这个指令是计算 <span class="hljs-built_in">ST</span>*<span class="hljs-number">2</span>^<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)之值，再把结果存入 <span class="hljs-built_in">ST</span> 里而 <span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)   之值不变。<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)  必须是在 -<span class="hljs-number">32768</span> 到 <span class="hljs-number">32768</span> (-<span class="hljs-number">215</span> 到 <span class="hljs-number">215</span> )之间的整数，如果超过这个范围计算结果无法确定，如果不是整数 <span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)    会先向零舍入成整数再计算。所以为安全起见，最好是由字组整数载入到 <span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>) 里。  <br>  <br><span class="hljs-keyword">FRNDINT</span>               这个指令是把 <span class="hljs-built_in">ST</span> 的数值舍入成整数，FPU    提供四种舍入方式，由 FPU 的控制字组(control    <span class="hljs-built_in">word</span>)中的 RC 两个位决定  <br>                          RC    舍入控制  <br>                          <span class="hljs-number">00</span>    四舍五入  <br>                          <span class="hljs-number">01</span>    向负无限大舍入  <br>                          <span class="hljs-number">10</span>    向正无限大舍入  <br>                          <span class="hljs-number">11</span>    向零舍去  <br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>汇编学习</div>
      <div>http://example.com/2023/03/27/汇编学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>luo</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月27日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                <i class="iconfont icon-nc"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                <i class="iconfont icon-sa"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/27/windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" title="windows核心编程">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">windows核心编程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/01/%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/" title="一些东西">
                        <span class="hidden-mobile">一些东西</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://beian.miit.gov.cn/" target="_blank">闽ICP备2021015815号-2</a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
