<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luo&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-30T05:28:52.817Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>luo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>寄存器种类及作用</title>
    <link href="http://example.com/2023/03/29/%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%8D%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2023/03/29/%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%8D%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8/</id>
    <published>2023-03-29T09:10:10.378Z</published>
    <updated>2023-03-30T05:28:52.817Z</updated>
    
    <content type="html"><![CDATA[<p>寄存器</p><p>英文名称：Register</p><h2 id="寄存器定义"><a href="#寄存器定义" class="headerlink" title="寄存器定义"></a>寄存器定义</h2><p> 　　寄存器是 <a href="http://baike.baidu.com/view/14045.htm">中央处理器</a>内的组成部份。 寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、 数据和位址。在中央处理器的控制部件中，包含的寄存器有 <a href="http://baike.baidu.com/view/178142.htm">指令寄存器</a>(IR)和 <a href="http://baike.baidu.com/view/178145.htm">程序计数器</a>(PC)。 在中央处理器的算术及逻辑部件中，包含的寄存器有 <a href="http://baike.baidu.com/view/471649.htm">累加器</a>( <a href="http://baike.baidu.com/view/331459.htm">ACC</a> )。<br> 　　寄存器是内存阶层中的最顶端， 也是系统获得操作资料的最快速途径。 寄存器通常都是以他们可以保存的位元数量来估量，举例来说，一个 “8 位元寄存器”或 “32 位元寄存器”。寄存器现在都以寄存器档案的方式来实作， 但是他们也可能使用单独的正反器、高速的核心内存、 薄膜内存以及在数种机器上的其他方式来实作出来。<br> 　　寄存器通常都用来意指由一个指令之输出或输入可以直接索引到的暂 存器群组。更适当的是称他们为 “架构寄存器”。<br> 　　例如，x86 指令及定义八个 32 位元寄存器的集合，但一个实作 x86 指令集的 CPU 可以包含比八个更多的寄存器。<br> 　　寄存器是CPU内部的元件，寄存器拥有非常高的读写速度， 所以在寄存器之间的数据传送非常快。  </p><h2 id="寄存器用途"><a href="#寄存器用途" class="headerlink" title="寄存器用途"></a>寄存器用途</h2><p> 　　1.可将寄存器内的数据执行算术及逻辑运算；<br> 　　2.存于寄存器内的地址可用来指向内存的某个位置，即寻址；<br> 　　3.可以用来读写数据到电脑的周边设备。  </p><h2 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h2><p> 　　8086 有14个16位寄存器，这14个寄存器按其用途可分为(1) 通用寄存器、(2)指令指针、(3)标志寄存器和(4) 段寄存器等4类。<br>(1)通用寄存器有8个, 又可以分成2组,一组是数据寄存器(4个), 另一组是指针寄存器及变址寄存器(4个).<br> 　　数据寄存器分为:<br>AH&amp;AL＝AX(accumulator)：累加寄存器， 常用于运算;在乘除等指令中指定用来存放操作数,另外, 所有的I&#x2F;O指令都使用这一寄存器与外界设备传送数据.<br>BH&amp;BL＝BX(base)：基址寄存器，常用于地址索引；<br>CH&amp;CL＝CX(count)：计数寄存器，常用于计数； 常用于保存计算值,如在移位指令,循环(loop) 和串处理指令中用作隐含的计数器.<br>DH&amp;DL＝DX(data)：数据寄存器，常用于数据传递。<br> 　　他们的特点是,这4个16位的寄存器可以分为高8位: AH, BH, CH, DH.以及低八位：AL,BL,CL,DL。 这2组8位寄存器可以分别寻址，并单独使用。<br> 　　另一组是指针寄存器和变址寄存器，包括：<br>SP（Stack Pointer）：堆栈指针，与SS配合使用， 可指向目前的堆栈位置；<br>BP（Base Pointer）：基址指针寄存器， 可用作SS的一个相对基址位置；<br>SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针 ；<br>DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。<br> 　　这4个16位寄存器只能按16位进行存取操作， 主要用来形成操作数的地址， 用于堆栈操作和变址运算中计算操作数的有效地址。<br> 　　( 2) 指令指针IP(Instruction Pointer)<br> 　　指令指针IP是一个16位专用寄存器， 它指向当前需要取出的指令字节， 当BIU从内存中取出一个指令字节后，IP就自动加1， 指向下一个指令字节。注意， IP指向的是指令地址的段内地址偏移量，又称偏移地址( Offset Address)或有效地址(EA，Effective Address)。<br>(3)标志寄存器FR(Flag Register)<br> 　　8086有一个18位的标志寄存器FR， 在FR中有意义的有9位，其中6位是状态位，3位是控制位。<br>OF： 溢出标志位OF用于反映有符号数加减运算所得结果是否溢出。 如果运算结果超过当前运算位数所能表示的范围，则称为溢出， OF的值被置为1，否则，OF的值被清为0。<br>DF：方向标志DF位用来决定在串操作指令执行时有关指针寄存器发生调整的方向。<br>IF：中断允许标志IF位用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值， CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求， 以及CPU内部产生的中断请求。具体规定如下：<br> 　　(1)、当IF&#x3D;1时， CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br> 　　(2)、当IF&#x3D;0时， CPU不响应CPU外部的可屏蔽中断发出的中断请求。<br>TF：跟踪标志TF。该标志可用于程序调试。 TF标志没有专门的指令来设置或清楚。<br> 　　（1）如果TF&#x3D;1，则CPU处于单步执行指令的工作方式，会产生单步中断， 此时每执行完一条指令， 就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令 。<br> 　　（2）如果TF&#x3D;0，则处于连续工作模式。<br>SF：符号标志SF用来反映运算结果的符号位， 它与运算结果的最高位相同。在微机系统中， 有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。 运算结果为负数时，SF的值为1，非负时为0。<br>ZF： 零标志ZF用来反映运算结果是否为0。如果运算结果为0， 则其值为1，否则其值为0。在判断运算结果是否为0时， 可使用此标志位。<br>AF：下列情况下，辅助进位标志AF的值被置为1， 否则其值为0：<br> 　　(1)、在字操作时，发生低字节向高字节进位或借位时；<br> 　　(2)、在字节操作时，发生低4位向高4位进位或借位时。<br>PF：奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。 如果“1”的个数为偶数，则PF的值为1，否则其值为0。  CF：进位标志CF主要用来反映（无符号数）运算是否产生进位或借位。 如果运算结果的最高位产生了一个进位或借位，那么，其值为1， 否则其值为0。)<br>4)段寄存器(Segment Register)<br> 　　为了运用所有的内存空间，8086设定了四个段寄存器， 专门用来保存段地址：<br>CS（Code Segment）：代码段寄存器；<br>DS（Data Segment）：数据段寄存器；<br>SS（Stack Segment）：堆栈段寄存器；<br>ES（Extra Segment）：附加段寄存器。<br> 　　当一个程序要执行时，就要决定程序代码、 数据和堆栈各要用到内存的哪些位置，通过设定段寄存器 CS，DS，SS 来指向这些起始位置。通常是将DS固定，而根据需要修改CS。 所以，程序可以在可寻址空间小于64K的情况下被写成任意大小。 所以，程序和其数据组合起来的大小，限制在DS 所指的64K内，这就是COM文件不得大于64K的原因。 8086以内存做为战场，用寄存器做为军事基地，以加速工作。<br> 　　以上是8086寄存器的整体概况, 自80386开始，PC进入32bit时代，其寻址方式， 寄存器大小, 功能等都发生了变化：<br> 　　&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 以下是80386的寄存器的一些资料&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br> 寄存器都是32-bits宽。<br> 　　A、通用寄存器<br> 　　下面介绍通用寄存器及其习惯用法。顾名思义， 通用寄存器是那些你可以根据自己的意愿使用的寄存器， 修改他们的值通常不会对计算机的运行造成很大的影响。 通用寄存器最多的用途是计算。<br> 　　EAX：通用寄存器。相对其他寄存器，在进行运算方面比较常用。 在保护模式中，也可以作为内存偏移指针（此时，DS作为段 寄存器或选择器）<br> 　　EBX：通用寄存器。通常作为内存偏移指针使用（相对于EAX、 ECX、EDX），DS是默认的段寄存器或选择器。 在保护模式中，同样可以起这个作用。<br> 　　ECX：通用寄存器。通常用于特定指令的计数。在保护模式中， 也可以作为内存偏移指针（此时，DS作为 寄存器或段选择器）。<br> 　　EDX：通用寄存器。在某些运算中作为EAX的溢出寄存器（ 例如乘、除）。在保护模式中，也可以作为内存偏移指针（此时， DS作为段 寄存器或选择器）。<br> 　　同AX分为AH&amp;AL一样，上述寄存器包括对应的16- bit分组和8-bit分组。<br> 　　B、用作内存指针的特殊寄存器<br> 　　ESI：通常在内存操作指令中作为“源地址指针”使用。当然， ESI可以被装入任意的数值， 但通常没有人把它当作通用寄存器来用。 DS是默认段寄存器或选择器。<br> 　　EDI：通常在内存操作指令中作为“目的地址指针”使用。当然， EDI也可以被装入任意的数值， 但通常没有人把它当作通用寄存器来用。 DS是默认段寄存器或选择器。<br> 　　EBP：这也是一个作为指针的寄存器。通常， 它被高级语言编译器用以建造‘堆栈帧’ 来保存函数或过程的局部变量，不过，还是那句话， 你可以在其中保存你希望的任何数据。 SS是它的默认段寄存器或选择器。<br> 　　注意，这三个寄存器没有对应的8-bit分组。换言之， 你可以通过SI、DI、BP作为别名访问他们的低16位， 却没有办法直接访问他们的低8位。<br> 　　C、段选择器：<br> 　　实模式下的段寄存器到保护模式下摇身一变就成了选择器。 不同的是，实模式下的“段寄存器”是16-bit的， 而保护模式下的选择器是32-bit的。<br> 　　CS 代码段，或代码选择器。同IP寄存器(稍后介绍) 一同指向当前正在执行的那个地址。 处理器执行时从这个寄存器指向的段（实模式）或内存（保护模式） 中获取指令。除了跳转或其他分支指令之外， 你无法修改这个寄存器的内容。<br> 　　DS 数据段，或数据选择器。这个寄存器的低16 bit连同ESI一同指向的指令将要处理的内存。同时， 所有的内存操作指令 默认情况下都用它指定操作段(实模式)或内存(作为选择器， 在保护模式。这个寄存器可以被装入任意数值， 然而在这么做的时候需要小心一些。方法是，首先把数据送给AX， 然后再把它从AX传送给DS(当然，也可以通过堆栈来做).<br> 　　ES 附加段，或附加选择器。这个寄存器的低16 bit连同EDI一同指向的指令将要处理的内存。同样的， 这个寄存器可以被装入任意数值，方法和DS类似。<br> 　　FS F段或F选择器(推测F可能是Free?)。 可以用这个寄存器作为默认段寄存器或选择器的一个替代品。 它可以被装入任何数值，方法和DS类似。<br> 　　GS G段或G选择器(G的意义和F一样， 没有在Intel的文档中解释)。它和FS几乎完全一样。<br> 　　SS 堆栈段或堆栈选择器。这个寄存器的低16 bit连同ESP一同指向下一次堆栈操作(push和pop) 所要使用的堆栈地址。这个寄存器也可以被装入任意数值， 你可以通过入栈和出栈操作来给他赋值， 不过由于堆栈对于很多操作有很重要的意义，因此， 不正确的修改有可能造成对堆栈的破坏。  </p><p> 　　* 注意 一定不要在初学汇编的阶段把这些寄存器弄混。他们非常重要， 而一旦你掌握了他们，你就可以对他们做任意的操作了。段寄存器， 或选择器，在没有指定的情况下都是使用默认的那个。 这句话在现在看来可能有点稀里糊涂， 不过你很快就会在后面知道如何去做。<br> 　　指令指针寄存器：<br> 　　 　　 EIP 这个寄存器非常的重要。这是一个32位宽的寄存器 ，同CS一同指向即将执行的那条指令的地址。 不能够直接修改这个寄存器的值， 修改它的唯一方法是跳转或分支指令。(CS是默认的段或选择器)<br> 　　* 上面是最基本的寄存器。下面是一些其他的寄存器， 你甚至可能没有听说过它们。(都是32位宽)：<br> 　　 CR0, CR2, CR3(控制寄存器)。举一个例子， CR0的作用是切换实模式和保护模式。<br> 　　 　　 还有其他一些寄存器，D0, D1, D2, D3, D6和D7(调试寄存器)。 他们可以作为调试器的硬件支持来设置条件断点。 TR3, TR4, TR5, TR6 和 TR? 寄存器(测试寄存器)用于某些条件测试</p><p>总结</p><p> 4个数据寄存器(EAX、EBX、ECX和EDX)<br> 2个变址和指针寄存器(ESI和EDI) 2个指针寄存器(ESP和EBP)<br> 6个段寄存器(ES、CS、SS、DS、FS和GS)<br> 1个指令指针寄存器(EIP) 1个标志寄存器(EFlags)</p><p> 1、数据寄存器<br>  数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。</p><p> 4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种”可分可合”的特性，灵活地处理字&#x2F;字节的信息。</p><p>寄存器AX和AL通常称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。累加器可用于乘、  除、输入&#x2F;输出等操作，它们的使用频率很高； 寄存器BX称为基地址寄存器(Base Register)。它可作为存储器指针来使用；  寄存器CX称为计数寄存器(Count Register)。在循环和字符串操作时，要用它来控制循环次数；在位操作  中，当移多位时，要用CL来指明移位的位数；<br> 寄存器DX称为数据寄存器(Data  Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I&#x2F;O的端口地址。在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。</p><p>2、变址寄存器<br> 32位CPU有2个32位通用寄存器ESI和EDI。其低16位对应先前CPU中的SI和DI，对低16位数据的存取，不影响高16位的数据。<br>寄存器ESI、EDI、SI和DI称为变址寄存器(Index  Register)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。<br>3、指针寄存器<br> 32位CPU有2个32位通用寄存器EBP和ESP。其低16位对应先前CPU中的SBP和SP，对低16位数据的存取，不影响高16位的数据。<br>寄存器EBP、ESP、BP和SP称为指针寄存器(Pointer  Register)，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。<br>它们主要用于访问堆栈内的存储单元，并且规定：<br>BP为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据；<br>SP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。<br>4、段寄存器<br> 段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成<br> 的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。<br> CPU内部的段寄存器：<br> CS——代码段寄存器(Code Segment Register)，其值为代码段的段值；<br> DS——数据段寄存器(Data Segment Register)，其值为数据段的段值；<br> ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；<br> SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值；<br> FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；<br> GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。</p><p>  在16位CPU系统中，它只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。32位CPU有两个不同的工作方式：实方式和保护方式。在每种方式下，段寄存器的作用是不同的。有关规定简单描述如下：<br> 实方式： 前4个段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致，内存单元的逻辑地址仍为”段值：偏移量”的形式。为访问某内存段内的数据，必须使用该段寄存器和存储单元的偏移量。<br> 保护方式： 在此方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为”选择子”(Selector)的某个值。<br> 5、指令指针寄存器<br> 32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。<br> 指令指针EIP、IP(Instruction Pointer)是存放下次将要执行的指令在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。<br> 在实方式下，由于每个段的最大范围为64K，所以，EIP中的高16位肯定都为0，此时，相当于只用其低16位的IP来反映程序中指令的执行次序。<br> 6、标志寄存器<br> 一、运算结果标志位<br> 1、进位标志CF(Carry Flag)<br> 进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。<br> 2、奇偶标志PF(Parity Flag)<br> 奇偶标志PF用于反映运算结果中”1″的个数的奇偶性。如果”1″的个数为偶数，则PF的值为1，否则其值为0。<br> 利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。<br> 3、辅助进位标志AF(Auxiliary Carry Flag)<br> 在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<br> (1)、在字操作时，发生低字节向高字节进位或借位时；<br> (2)、在字节操作时，发生低4位向高4位进位或借位时。<br> 对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。<br> 4、零标志ZF(Zero Flag)<br> 零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br> 5、符号标志SF(Sign Flag)<br> 符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。<br> 6、溢出标志OF(Overflow Flag)<br>  溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。”溢出”和”进位”是两个不同含义的概念，不要混淆。如果不太清楚的话，请查阅《计算机组成原理》课程中的有关章节。<br> 二、状态控制标志位<br> 状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。<br> 1、追踪标志TF(Trap Flag)<br> 当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。<br> 2、中断允许标志IF(Interrupt-enable Flag)<br> 中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：<br> (1)、当IF&#x3D;1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br> (2)、当IF&#x3D;0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。<br> CPU的指令系统中也有专门的指令来改变标志位IF的值。<br> 3、方向标志DF(Direction Flag)<br> 方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节——字符串操作指令——中给出。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。<br> 三、32位标志寄存器增加的标志位<br> 1、I&#x2F;O特权标志IOPL(I&#x2F;O Privilege Level)<br> I&#x2F;O特权标志用两位二进制位来表示，也称为I&#x2F;O特权级字段。该字段指定了要求执行I&#x2F;O指令的特权级。如果当前的特权级别在数值上小于等于IOPL的值，那么，该I&#x2F;O指令可执行，否则将发生一个保护异常。<br> 2、嵌套任务标志NT(Nested Task)<br> 嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下：<br> (1)、当NT&#x3D;0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作；<br> (2)、当NT&#x3D;1，通过任务转换实现中断返回。<br> 3、重启动标志RF(Restart Flag)<br> 重启动标志RF用来控制是否接受调试故障。规定：RF&#x3D;0时，表示”接受”调试故障，否则拒绝之。在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1。<br> 4、虚拟8086方式标志VM(Virtual 8086 Mode)<br> 如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;寄存器&lt;/p&gt;
&lt;p&gt;英文名称：Register&lt;/p&gt;
&lt;h2 id=&quot;寄存器定义&quot;&gt;&lt;a href=&quot;#寄存器定义&quot; class=&quot;headerlink&quot; title=&quot;寄存器定义&quot;&gt;&lt;/a&gt;寄存器定义&lt;/h2&gt;&lt;p&gt; 　　寄存器是 &lt;a href=&quot;http://ba</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>windows核心编程</title>
    <link href="http://example.com/2023/03/27/windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2023/03/27/windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</id>
    <published>2023-03-27T14:38:53.168Z</published>
    <updated>2023-03-29T23:24:06.058Z</updated>
    
    <content type="html"><![CDATA[<p>1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>汇编学习</title>
    <link href="http://example.com/2023/03/27/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/03/27/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-27T14:38:12.301Z</published>
    <updated>2023-03-29T15:33:17.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、汇编语言是什么？"><a href="#一、汇编语言是什么？" class="headerlink" title="一、汇编语言是什么？"></a>一、汇编语言是什么？</h2><p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p><p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html">编译器</a>的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p><p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p><p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p><h2 id="二、来历"><a href="#二、来历" class="headerlink" title="二、来历"></a>二、来历</h2><p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p><p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。</p><p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做  assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为  asm，中文译为汇编语言。每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p><h2 id="三、寄存器"><a href="#三、寄存器" class="headerlink" title="三、寄存器"></a>三、寄存器</h2><p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p><p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU  的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p><p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU  还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU  优先读写寄存器，再由寄存器跟内存交换数据。</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281441087.png" alt="image-20230328144102980"></p><p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p><h2 id="四、寄存器的种类"><a href="#四、寄存器的种类" class="headerlink" title="四、寄存器的种类"></a>四、寄存器的种类</h2><p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。一般寄存器:AX、BX、CX、DX，索引暂存器:SI、DI，堆叠、基底暂存器:SP、BP。EAX、ECX、EDX、EBX：为ax,bx,cx,dx的延伸，各为32位元<br>ESI、EDI、ESP、EBP：为si,di,sp,bp的延伸，32位元。eax, ebx, ecx, edx, esi, edi, ebp, esp等都是X86 汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。如果用C语言来解释，可以把这些寄存器当作变量看待。</p><p>这些32位寄存器有多种用途，但每一个都有“专长”，有各自的特别之处。</p><p>EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。</p><p>EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址。</p><p>ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。</p><p>EDX 则总是被用来放整数除法产生的余数。</p><p>ESI&#x2F;EDI分别叫做”源&#x2F;目标索引寄存器”(source&#x2F;destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.</p><blockquote><p>​push ebp ;保存当前ebp<br>　mov ebp,esp ;EBP设为当前堆栈指针<br>　sub esp, xxx ;预留xxx字节给函数临时变量.<br>　…　　</p></blockquote><p>这样一来,EBP 构成了该函数的一个框架, 在EBP上方分别是原来的EBP, 返回地址和参数. EBP下方则是临时变量. 函数返回时作 mov esp,ebp&#x2F;pop ebp&#x2F;ret 即可.</p><p>ESP 专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。</p><p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p><h2 id="五、内存模型：Heap"><a href="#五、内存模型：Heap" class="headerlink" title="五、内存模型：Heap"></a>五、内存模型：Heap</h2><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281451635.png" width="40%"><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281500821.png" width="40%/"><p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h2 id="六、内存模型：Stack"><a href="#六、内存模型：Stack" class="headerlink" title="六、内存模型：Stack"></a>六、内存模型：Stack</h2><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281502145.png" width="40%/"><p>请看下面的例子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clike">int main() &#123;<br>   int a = 2;<br>   int b = 3;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281503456.png" width="40%"><p>如果函数内部调用了其他函数，会发生什么情况？</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clike">int main() &#123;<br>   int a = 2;<br>   int b = 3;<br>   return add_a_and_b(a, b);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281504175.png" width="40%"><p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是  push；栈的回收叫做”出栈”，英文是 pop。Stack  的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281505057.png" width="40%"><h2 id="七、CPU-指令"><a href="#七、CPU-指令" class="headerlink" title="七、CPU 指令"></a>七、CPU 指令</h2><h3 id="7-1-一个实例"><a href="#7-1-一个实例" class="headerlink" title="7.1 一个实例"></a>7.1 一个实例</h3><p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clike">int add_a_and_b(int a, int b) &#123;<br>   return a + b;<br>&#125;<br><br>int main() &#123;<br>   return add_a_and_b(2, 3);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>gcc 将这个程序转成汇编语言。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -S example.c<br></code></pre></td></tr></table></figure></blockquote><p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p><p><code>example.s</code>经过简化以后，大概是下面的样子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clike">_add_a_and_b:<br>push   %ebx//esp-4<br>mov    %eax, [%esp+8]// 取2<br>mov    %ebx, [%esp+12]// 取3<br>add    %eax, %ebx//a+b值存在eax中<br>pop    %ebx//ebx弹出栈，esp+4<br>ret//退出程序执行<br><br>_main:<br>push   3//压栈，整型占4字节，esp栈顶指针-4<br>push   2//压栈，esp-4<br>call   _add_a_and_b//调用add函数<br>add    %esp, 8 //esp+8 保存在esp中<br>ret//退出程序执行<br></code></pre></td></tr></table></figure></blockquote><p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p><p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   %ebx<br></code></pre></td></tr></table></figure></blockquote><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p><h3 id="7-2-push-指令"><a href="#7-2-push-指令" class="headerlink" title="7.2 push 指令"></a>7.2 push 指令</h3><p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p><p>然后，开始执行第一行代码。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   3<br></code></pre></td></tr></table></figure></blockquote><p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p><p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   2<br></code></pre></td></tr></table></figure></blockquote><p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012216.png" alt="img"></p><h3 id="7-3-call-指令"><a href="#7-3-call-指令" class="headerlink" title="7.3 call 指令"></a>7.3 call 指令</h3><p>第三行的<code>call</code>指令用来调用函数。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">call   _add_a_and_b<br></code></pre></td></tr></table></figure></blockquote><p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p><p>下面就开始执行<code>_add_a_and_b</code>的代码。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   %ebx<br></code></pre></td></tr></table></figure></blockquote><p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p><p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p><h3 id="7-4-mov-指令"><a href="#7-4-mov-指令" class="headerlink" title="7.4 mov 指令"></a>7.4 mov 指令</h3><p><code>mov</code>指令用于将一个值写入某个寄存器。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">mov    %eax, [%esp+8] <br></code></pre></td></tr></table></figure></blockquote><p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p><p>下一行代码也是干同样的事情。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">mov    %ebx, [%esp+12] <br></code></pre></td></tr></table></figure></blockquote><p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p><h3 id="7-5-add-指令"><a href="#7-5-add-指令" class="headerlink" title="7.5 add 指令"></a>7.5 add 指令</h3><p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">add    %eax, %ebx<br></code></pre></td></tr></table></figure></blockquote><p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p><h3 id="7-6-pop-指令"><a href="#7-6-pop-指令" class="headerlink" title="7.6 pop 指令"></a>7.6 pop 指令</h3><p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">pop    %ebx<br></code></pre></td></tr></table></figure></blockquote><p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p><p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p><h3 id="7-7-ret-指令"><a href="#7-7-ret-指令" class="headerlink" title="7.7 ret 指令"></a>7.7 ret 指令</h3><p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">ret<br></code></pre></td></tr></table></figure></blockquote><p>可以看到，该指令没有运算子。</p><p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">add    %esp, 8 <br></code></pre></td></tr></table></figure></blockquote><p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">ret<br></code></pre></td></tr></table></figure></blockquote><p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、汇编语言是什么？&quot;&gt;&lt;a href=&quot;#一、汇编语言是什么？&quot; class=&quot;headerlink&quot; title=&quot;一、汇编语言是什么？&quot;&gt;&lt;/a&gt;一、汇编语言是什么？&lt;/h2&gt;&lt;p&gt;我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一些东西</title>
    <link href="http://example.com/2022/10/01/%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/"/>
    <id>http://example.com/2022/10/01/%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/</id>
    <published>2022-09-30T16:00:00.000Z</published>
    <updated>2023-03-29T23:30:17.249Z</updated>
    
    <content type="html"><![CDATA[<p>x32是x86架构的32位拓展，向后兼容于16位的x86架构。计算机的CPU一次最多能处理32位数据。，当然32位计算机通常也可以处理16位和8位数据。</p><p>x64是x86架构的64位拓展，向后兼容于16位及32位的x86架构。x64于1999年由AMD设计，AMD首次公开64位集以扩展给x86，称为“AMD64”。其后也为英特尔所采用。</p><p>x86是一个intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合，X与处理器没有任何关系，它是一个对所有＊86系统的简单的通配符定义。</p><p>&#x2F;&#x2F;x96dbg是安装x32dbg和x64dbg用的</p><p>图片大小</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">xxx.png</span> <span class="hljs-attr">width</span>=<span class="hljs-string">40%</span> /&gt;</span> or <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> =<span class="hljs-string">xxx.png</span> <span class="hljs-attr">width</span>=<span class="hljs-string">100</span> <span class="hljs-attr">height</span>=<span class="hljs-string">100/</span>&gt;</span><br></code></pre></td></tr></table></figure><p>各种数据类型字节数</p><table><thead><tr><th align="center">数据类型</th><th align="center">字节</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">short</td><td align="center">2</td><td align="center">0</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">0</td></tr><tr><td align="center">long</td><td align="center">8</td><td align="center">0</td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">0.0f</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">0.0d</td></tr><tr><td align="center">char</td><td align="center">2</td><td align="center">‘\u0000’</td></tr><tr><td align="center">boolean</td><td align="center">4（根据编译环境而定）</td><td align="center">false</td></tr></tbody></table><p>表格：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 空格 </span>|<span class="hljs-string"> 空格 </span>|<br></code></pre></td></tr></table></figure><p>伪指令又称为伪操作，它是<strong>在对源程序汇编期间由汇编程序处理的操作</strong>，它们可以完成如处理器选择、定义程序模式、定义数据、分配存储区、指示程序结束等功能。</p><p>hexo博客不更新，把.deploy_git文件夹删除，再hexo g -d</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;x32是x86架构的32位拓展，向后兼容于16位的x86架构。计算机的CPU一次最多能处理32位数据。，当然32位计算机通常也可以处理16位和8位数据。&lt;/p&gt;
&lt;p&gt;x64是x86架构的64位拓展，向后兼容于16位及32位的x86架构。x64于1999年由AMD设计，AM</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>杂七杂八的东西</title>
    <link href="http://example.com/2022/10/01/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <id>http://example.com/2022/10/01/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF/</id>
    <published>2022-09-30T16:00:00.000Z</published>
    <updated>2023-03-30T14:55:05.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="月象"><a href="#月象" class="headerlink" title="月象"></a>月象</h1><ul><li>新月</li></ul><p><img src="/.com//Users\罗\AppData\Roaming\Typora\typora-user-images\image-20230330225236905.png" alt="新月"></p><p>新月是指在农历的每月月初，月球逐渐远离太阳，月牙渐渐露出来的月相。新月时，月亮仅露出一弯月牙，并且朝右弯曲。随着月球运动，月牙越来越大。到初六初七左右，半个月亮已经露出来了，新月就变成了上弦月。从农历月初到初六左右，这段时间的月相都叫新月。</p><p>新月时，天球上月球与太阳相距不超过90°，因此月亮比太阳稍晚升起，稍晚落下。</p><ul><li>峨眉月</li></ul><p>蛾眉月（waxing Crescent moon ），农历月底和月初的月亮或月相。形状如同眉毛，由此得名。分为新月蛾眉月和残月蛾眉月。新月蛾眉月于月初傍晚出现在西方天空，月面朝西，呈反C状。残月蛾眉月是在月末的黎明，出现在东方天空，月面朝东，呈C状。</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303302254515.png" alt="image-20230330225422469"></p><ul><li>上弦月</li></ul><p>上弦月是指在农历的每月初七、初八，<a href="https://baike.baidu.com/item/%E6%9C%88%E7%90%83/30767?fromModule=lemma_inlink">月球</a>与太阳相距90°，月球的一半被照亮的<a href="https://baike.baidu.com/item/%E6%9C%88%E7%9B%B8/2747315?fromModule=lemma_inlink">月相</a>。上弦月时，月亮的一半被照亮，为<a href="https://baike.baidu.com/item/%E5%8D%8A%E5%9C%86%E5%BD%A2/8653950?fromModule=lemma_inlink">半圆形</a>。弦在左，弓背在右。随着月球运动，月亮被照亮的范围越来越大，看起来不再是一个半圆形了，这时候上弦月变成了<a href="https://baike.baidu.com/item/%E7%9B%88%E5%87%B8%E6%9C%88/14745757?fromModule=lemma_inlink">盈凸月</a>。</p><h1 id="激素与幸福"><a href="#激素与幸福" class="headerlink" title="激素与幸福"></a>激素与幸福</h1><p>幸福具体是什么<br>幸福是由三种脑内物质构成的</p><p><strong>多巴胺</strong> ，<strong>血清素</strong>，<strong>催产素</strong><br>和三原色相似，这三类脑内物质也能调配出幸福。<br>血清素的幸福:健康的幸福<br>催产素的幸福:爱和人际关系的幸福<br>多巴胺的幸福:钱成功富有名利的幸福<br>幸福是有优先顺序的。<br>首先是血清素然后是催产素最后才是多巴胺<br>如果比起健康更重视成功的话…<br>很容易患上心理和身体上疾患，容易变得不幸<br>应该首先重视健康，然后由轻重缓急地努力。<br>[努力]必须要有[健康]作为基石<br>如果比起爱和人际关系更重视成功的话……<br>会发挥出巨大的反向复利效果。越老越后悔<br>多巴胺的幸福就像是建筑,我们只看得到这个部分,但如果没有挖出足够支撑建筑的地基(血清素和催产素)，那么它就是摇摇欲坠的。</p><hr><p>血清素的幸福到底是什么<br>注意自己的[状态] [心情]<br>身心健康</p><ul><li>感觉很清爽</li><li>可以放松，可以发呆</li><li>注意力非常集中，平常心，可以控制感情，mindfulness的状态</li><li>运动之后心情不错</li><li>在大自然中感觉很舒服</li><li>健康，没有疾患</li></ul><p>如果感觉[心理难受] [状态不好]就一定要重视<br>抑郁症就是究极的血清素分泌不足的情况<br>失去血清素的幸福的状态:<br>心情低落啥都不想做</p><ul><li>情绪不稳定不安易怒容易发火</li><li>身体状态很差</li><li>集中不了注意力</li><li>生病</li><li>不想活了想死</li></ul><p>如果总是忘东西，工作或者学习上老出错，那么很可能血清素不足<br>这是一种在失去之前被当做理所当然的幸福。<br>虽然是[理所当然],但却是[千金不换]的幸福<br>[健康]这种东西是在失去时才发现的。<br>具有血清素幸福的人会被人信赖(状态稳定)<br>催产素的幸福又是什么?<br>和他人的交流，从关系中产生的幸福。</p><ul><li>夫妇关系</li><li>亲子关系</li><li>友情</li><li>社群</li><li>对于自己所属群体的归属感</li><li>宠物</li></ul><p>丧失了催产素的状态</p><ul><li>寂寞没有朋友</li><li>为人际关系苦恼被排斥</li><li>孤立无援</li></ul><hr><p>多巴胺的幸福<br>基本印象就是[成功] [达成]<br>要得到多巴胺的幸福，需要支付[代价]<br>多巴胺是一种[渴求更多]的物质<br>多巴胺是我们[动机] [想要去做]的原动力，有了多巴胺就能更加[努力],作为结果的[自<br>我成长]也会显现。<br>多巴胺的幸福的具体表现</p><ul><li>成功:钱财产富有名利</li><li>动力:目标设定达成，自我成长，报酬</li><li>承认欲望:想被点赞</li><li>快乐物质:食欲快乐爱好</li></ul><p>多巴胺暴走之后，就会形成依存症。<br>对于多巴服报酬系的依赖</p><ul><li>物质依存:酒精药物烟瘾咖啡因</li><li>行动依存:赌博买买买游戏手机网瘾性行为</li><li>人际关系依存:家庭暴力 ( 依然不离开)共依存</li></ul><hr><p>幸福的[意外性质]<br>不明白幸福的性质就无法把它变为自己的东西，幸福不是结果，而是过程</p><ul><li>幸福就在这里<br>[Be]的幸福:每天有人做饭，早起有饭吃，这就是已经存在的催产素的幸福。我<br>们很难有意识地去注意到。要保持它，不失去是需要我们的努力的。<br>[Do]的幸福:多巴胺的幸福</li><li>幸福就在当下<br>一点一滴的小成就也会促进多巴胺的分泌。这就是小幸福。<br>幸福不在未来，就在现在。<br>不是[达成成就]才会获得幸福，而是[在达成成就的路上]<br>多巴胺带来的幸福是会递减的，这是多巴胺的特征。<br>就算这次得到同样的刺激，如果下次没有比这个更多，多巴胺就不会分泌。就算获得了多巴胺，也无法持续下去。<br>不要陷入多巴胺的沼泽:为了更多的奖金和前景，不断加班损害身体。<br>但是血清素和催产素的幸福不会递减。<br>眺望青空一百次，一千次，这种爽快的感觉不会递减。<br>这三种幸福都可以得到。</li></ul><hr><p>[三种幸福]的科学依据<br>血清素是控制人生的指挥者</p><ul><li><p>平时就好好锻炼血清素的话，就能够防止多巴胺的依存症。</p></li><li><p>血清素就像控制[暴走的马]的[马鞭]</p></li><li><p>多分泌催产素就能变得更加健康</p></li><li><p>身体健康:免疫力上升，细胞修复上升，自然治愈力上升。血压下降，脉搏下降。心脏病的发病可能下降</p></li></ul><p>减少压力。<br>*记忆力学习能力好奇心上升。<br>催产素:人际关系的幸福能作为多巴胺的刹车存在<br>值产素能抑制想要吸烟喝酒的欲望。<br>大家一起做更开心的证据<br>*不论是做事还是和谁- 起开心，加上了[催产素]的相乘效果，就会更开心。.<br>*催产素是防止|心理状况恶化]的预防物质。<br>*一个行动就能产生复数脑内物质。比如微笑会同时产生复数脑内物质</p><h1 id="爱情？"><a href="#爱情？" class="headerlink" title="爱情？"></a>爱情？</h1><p>爱情三角理论由美国心理学家斯腾伯格提出，认为爱情由三个基本成分组成：激情、亲密和承诺。</p><p>激情是爱情中的性欲成分，是情绪上的着迷；亲密是指在爱情关系中能够引起的温暖体验；承诺指维持关系的担保。</p><p>这三种成分构成了喜欢式爱情、迷恋式爱情等 7 种类型。下面将对三个要素简单的介绍，最后对 7 种类型做出介绍。</p><p>三要素：</p><ul><li>亲密（Intimacy）</li></ul><p>亲密包括热情、理解、沟通、支持和分享等爱情关系中常见的特征，一般来说包含下面十个基本要素：</p><ol><li><p>渴望促进被爱者的幸福，在必要时也希望对方能这么做</p></li><li><p>跟被爱者在一起时感到幸福</p></li><li><p>尊重对方</p></li><li><p>跟被爱方互相理解</p></li><li><p>与被爱方分享自我和自己的占有物</p></li><li><p>从被爱方接受感情上的支持</p></li><li><p>给予被爱方感情上的支持</p></li><li><p>跟被爱方亲切沟通</p></li><li><p>尊重被爱方</p></li><li><p>珍重被爱方</p></li></ol><ul><li>激情（Passion）</li></ul><p>激情的主要特征为性的唤醒和欲望，是一种强烈地想要和对方结合的状态，简单来说，就是见了对方，会有一种怦然心动的感觉，和对方相处，有一种兴奋的体验。激情可以是积极的，也可以是消极的。</p><p>激情经历 3 个阶段：</p><ol><li><p>由于意识控制减弱，身体的变化和表情动作越来越失去控制。人的行为服从于所体验的情感。</p></li><li><p>人失去意志的监督，发生不可控制的动作和失去理智的行为，这些动作在事后回想起来会感到羞耻和后悔。</p></li><li><p>出现在激情爆发之后，此时会出现平静和某种疲劳的现象，严重时会出现精力衰竭，对一切事物都抱着不关心的态度，有事还会精神萎靡，即所谓激情休克。</p></li></ol><ul><li>承诺（Commitment）</li></ul><p>承诺是指投身于爱情和努力维护爱情的决心。如果说亲密是情感性的，激情是驱动性的，那承诺就是认知性的。</p><p>它由两方面组成：短期的和长期的。</p><ol><li><p>短期方面就是要做出一个爱不爱对方的决定</p></li><li><p>长期方面就是做出维护爱情关系的长期的承诺。</p></li></ol><p>恋情发展的四类形式：</p><ol><li><p>加速-停止型：起初进展极快，然後逐渐缓慢，无法走入婚姻；</p></li><li><p>加速型：速度不若加速-停止型快，走得顺畅，感情有增无减；</p></li><li><p>中度型：速度较前两型慢；</p></li><li><p>延长型：步调慢，长路多年，也许有结果，也许说分手。</p></li></ol><p>八种爱情类型（看看自己是哪一种）</p><ol><li><p>无爱式：亲密、激情和承诺三者都缺失，爱情就不存在。两个人可能仅仅是泛泛之交而不是朋友，彼此的关系是随意、肤浅和不受约束的。</p></li><li><p>喜欢式：当亲密程度高，但激情和承诺都非常低时，只有亲密，在一起时感觉很舒服，多表现为友谊。</p></li><li><p>迷恋式：缺乏亲密或承诺，却又强烈的激情。认为对方有强烈的吸引力，但除此之外，对对方的了解不多，也没有想过将来，就像初恋，或一夜情。</p></li><li><p>空洞式：只有承诺，缺乏亲密和激情。常见于激情燃尽的爱情关系中，既没有温情也没有激情，仅仅在一起过日子，如包办婚姻等，纯粹为了结婚的爱情。</p></li><li><p>浪漫式：有着强烈的亲密体验和激情体验，但缺乏承诺。崇尚过程，不在乎结果。</p></li><li><p>伴侣式：亲密和承诺结合在一起所形成的爱，双方会努力维持深刻、长久的友谊，这种爱情表现出亲近、沟通、分享以及对爱情关系的巨大投入。像长久而幸福的婚姻，虽然激情已经逐渐消失。</p></li><li><p>愚昧式：却是亲密的激情和承诺会产生愚蠢的爱情体验，这种爱情会发生在旋风般的求爱中，在压倒一切的激情基础上双方会闪电般击昏，但并不是很了解或者喜欢对方。</p></li><li><p>完美爱情：同时具备三要素，但这种爱情一般认为短时间里容易做到，但很难长久维持。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;月象&quot;&gt;&lt;a href=&quot;#月象&quot; class=&quot;headerlink&quot; title=&quot;月象&quot;&gt;&lt;/a&gt;月象&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;新月&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/.com//Users\罗\AppData\Roaming\Typora</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>日记</title>
    <link href="http://example.com/2022/10/01/%E6%97%A5%E8%AE%B0/"/>
    <id>http://example.com/2022/10/01/%E6%97%A5%E8%AE%B0/</id>
    <published>2022-09-30T16:00:00.000Z</published>
    <updated>2023-03-27T00:01:23.545Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="33ce420ed77c75ae5a1e3baad6a200a61fbd8520c0be474ff0b95caba26cd0ce">98b9bce3395e8307c58744c1268884247d0a5b3479230fb31ca4bed820a86c27422cc91a4ea7f27c7326dd970a974961d932a75619370158c1ac5c95281050db413f7a6cf0dd06320e44b09e0d148775bab7f9ee61722aaf85a226c4934152a5739e168613ce305d7b6be75fc6ffd788d31c93fdd262684b9b97f961610e2b45</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">仅用于个人记录</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Enter password to read.</summary>
    
    
    
    <category term="日常记录" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="日常记录" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/09/11/helloworld/"/>
    <id>http://example.com/2022/09/11/helloworld/</id>
    <published>2022-09-11T12:08:09.403Z</published>
    <updated>2023-03-29T09:34:04.068Z</updated>
    
    <content type="html"><![CDATA[<p>hi~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hi~&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
