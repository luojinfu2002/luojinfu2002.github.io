<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luo&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-04T07:17:23.837Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>luo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/07/26/WINDOWS%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2023/07/26/WINDOWS%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8/</id>
    <published>2023-07-26T06:52:48.130Z</published>
    <updated>2023-08-04T07:17:23.837Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-WINDOWS逆向"><a href="#title-WINDOWS逆向" class="headerlink" title="title:WINDOWS逆向"></a>title:WINDOWS逆向</h2><h1 id="WINDOWS逆向"><a href="#WINDOWS逆向" class="headerlink" title="WINDOWS逆向"></a>WINDOWS逆向</h1><ul><li>进制</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.进制的定义 <span class="hljs-number">2</span>.进制的运算 <span class="hljs-number">3</span>.源码反码补码移码<br></code></pre></td></tr></table></figure><ul><li>汇编</li></ul><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">阶段概述<br><span class="hljs-keyword">x</span><span class="hljs-number">86</span>汇编基础<br><span class="hljs-keyword">x</span><span class="hljs-number">64</span>汇编基础<br>Win<span class="hljs-number">32</span>汇编基础<br></code></pre></td></tr></table></figure><ul><li>c</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">阶段概述<br>变量<br>函数<br>三大结构<br>数组<br>指针<br>动态内存管理<br>文件I/O<br>结构体<span class="hljs-regexp">/联合体/</span>枚举<br>预处理器<br></code></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">引用<br>面向对象<br>类<br>虚函数<br>封装<br>继承<br>多态<br></code></pre></td></tr></table></figure><ul><li>逆向基础篇</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span>逆向分析<br><span class="hljs-operator">.</span><span class="hljs-variable">NET</span>逆向分析<br><span class="hljs-variable">Java</span>逆向分析<br>本地程序破解<br>网络程序破解<br>注册机编写<br></code></pre></td></tr></table></figure><ul><li>数据库</li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">Mysql基础知识</span><br><span class="hljs-comment">Mysql创建数据库与表</span><br><span class="hljs-comment">Mysql增删改查</span><br><span class="hljs-comment">Mysql高级技术</span><br><span class="hljs-comment">C</span><span class="hljs-literal">++</span><span class="hljs-comment">与Mysql</span><br></code></pre></td></tr></table></figure><ul><li>硬编码</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">基础概念<br>定长编码<br>变长编码<br></code></pre></td></tr></table></figure><ul><li>ShellCode</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">基础理论<br>poc<br>Exploit<br><span class="hljs-keyword">shellcode定位</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">shellcode功能开发</span><br><span class="hljs-keyword"></span>动态函数获取<br>处理“坏字符”<br>突破系统保护-Ret2Libc<br>突破系统保-Rop<br></code></pre></td></tr></table></figure><ul><li>反调试</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">基于系统API的反调试<br>基于环境监测的反调试<br>基于异常处理的反调试<br>基于调试器行为的反调试<br></code></pre></td></tr></table></figure><ul><li>反虚拟机</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">基于环境监测的反虚拟机<br>基于其他条件的反虚拟机<br></code></pre></td></tr></table></figure><ul><li>壳</li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">加壳：压缩壳，加密壳，虚拟化壳</span><br><span class="hljs-comment">写壳：汇编壳，c</span><span class="hljs-literal">++</span><span class="hljs-comment">壳</span><br><span class="hljs-comment">脱壳：压缩壳，加密壳</span><br></code></pre></td></tr></table></figure><ul><li>算法</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">时间复杂的<br>检索算法<br>排序算法<br>字符串相关算法<br></code></pre></td></tr></table></figure><ul><li>网络开发</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">计算机网络基础<br><span class="hljs-variable">Winsock</span><br>网络<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>模型<br>完成端口<br>互联网广播与<span class="hljs-variable">IP</span>多播<br>原始套接字<br><span class="hljs-variable">P2P</span>技术<br>协议分析<br></code></pre></td></tr></table></figure><ul><li>Windows程序设计</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">窗口与消息<br>绘图<br>鼠标<br>键盘<br>计时器<br>子窗口<br>文本字体<br>图像<br>动态链接库<br></code></pre></td></tr></table></figure><ul><li>MFC程序设计</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">基础概念<br>消息映射<br>输入输出<br>MFC类与变量<br>MFC集合类<br>基础控件<br>高级控件<br>文件I/O与串行化<br>对话框<br>单文档程序<br>多文档程序<br>工具栏<span class="hljs-regexp">/状态栏/</span>组合栏<br>COM<br>OLE<br>Automation<br>ActiveX<br></code></pre></td></tr></table></figure><ul><li>Windows核心编程</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">错误处理<br>字符串处理<br>内核对象<br>进程<br>线程<br>线程调度<br>线程同步<br>同步设备<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>与异步设备<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><br>线程池<br>内存管理<br>堆<br><span class="hljs-variable">DLL</span><br>高级<span class="hljs-variable">DLL</span>技术<br>线程局部存储<br>注入与<span class="hljs-variable">hook</span><br>异常处理<br>错误报告与引用恢复<br></code></pre></td></tr></table></figure><ul><li>密码学</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">基础概念<br>单项散列函数<br>对称加密算法<br>公开密钥加密算法<br>其他算法<br></code></pre></td></tr></table></figure><ul><li>调试原理</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">基础理论<br>保护模式<br>中断与异常<br>断点与单步执行<br>用户态调试流程<br>中断与异常管理<br>调试器实现原理<br></code></pre></td></tr></table></figure><ul><li>PE结构</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gauss">什么是PE<br>MS-<span class="hljs-keyword">DOS</span>头<br>PE头<br>区段<br>导入表<br>导出表<br>资源表<br>重定位<br>TLS<br>延迟载入<br>手写最小PE<br>PE编辑器开发<br></code></pre></td></tr></table></figure><ul><li>数据结构</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">线性表<br>链表<br>栈与队列<br>图<br>堆<br>散列<br></code></pre></td></tr></table></figure><ul><li>恶意代码</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">理论：恶意代码基础，恶意代码历史，恶意代码现状，恶意代码发展趋势<br>编码：恶意代码基本架构设计，功能模块设计，通信模块设计，对抗模块设计，传播模块设计，总体架构，反调试实现，反虚拟机实现，感染实现，通信实现，横向移动实现，漏洞利用实现，破坏性实现，功能性实现，混淆，白加黑<br>分析：恶意代码快速分析，静态分析，动态分析，本地行为分析，网络行为分析，对抗反调试，对抗反虚拟机，对抗混淆，对抗白加黑，<span class="hljs-keyword">shellcode分析，其他功能分析</span><br><span class="hljs-keyword"></span>案例：熊猫烧香，Wannacry，<span class="hljs-keyword">Bad </span>Rabbit，Oceanlotus<br></code></pre></td></tr></table></figure><ul><li>漏洞</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">漏洞基础：漏洞的概念，价值，现状，发展趋势，栈溢出漏洞，堆溢出漏洞，整数溢出漏洞，格式化字符串漏洞，双重释放漏洞，释放重引用漏洞，数组越界漏洞<br>文档漏洞：案例cve<span class="hljs-string">-2010</span><span class="hljs-string">-2883</span>，案例cve<span class="hljs-string">-2012</span><span class="hljs-string">-1876</span><br>漏洞挖掘：FUZZ的基本概念，文件格式FUZZ,网络协议FUZZ,浏览器FUZZ，其他FUZZ<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-WINDOWS逆向&quot;&gt;&lt;a href=&quot;#title-WINDOWS逆向&quot; class=&quot;headerlink&quot; title=&quot;title:WINDOWS逆向&quot;&gt;&lt;/a&gt;title:WINDOWS逆向&lt;/h2&gt;&lt;h1 id=&quot;WINDOWS逆</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/07/25/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/07/25/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/</id>
    <published>2023-07-25T05:52:34.696Z</published>
    <updated>2023-07-25T15:33:46.770Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>寄存器种类及作用</title>
    <link href="http://example.com/2023/03/29/%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%8D%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2023/03/29/%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%8D%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8/</id>
    <published>2023-03-29T09:10:10.378Z</published>
    <updated>2023-04-05T14:53:41.457Z</updated>
    
    <content type="html"><![CDATA[<p>寄存器</p><p>英文名称：Register</p><h2 id="寄存器定义"><a href="#寄存器定义" class="headerlink" title="寄存器定义"></a>寄存器定义</h2><p> 　　寄存器是 <a href="http://baike.baidu.com/view/14045.htm">中央处理器</a>内的组成部份。 寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、 数据和位址。在中央处理器的控制部件中，包含的寄存器有 <a href="http://baike.baidu.com/view/178142.htm">指令寄存器</a>(IR)和 <a href="http://baike.baidu.com/view/178145.htm">程序计数器</a>(PC)。 在中央处理器的算术及逻辑部件中，包含的寄存器有 <a href="http://baike.baidu.com/view/471649.htm">累加器</a>( <a href="http://baike.baidu.com/view/331459.htm">ACC</a> )。<br> 　　寄存器是内存阶层中的最顶端， 也是系统获得操作资料的最快速途径。 寄存器通常都是以他们可以保存的位元数量来估量，举例来说，一个 “8 位元寄存器”或 “32 位元寄存器”。寄存器现在都以寄存器档案的方式来实作， 但是他们也可能使用单独的正反器、高速的核心内存、 薄膜内存以及在数种机器上的其他方式来实作出来。<br> 　　寄存器通常都用来意指由一个指令之输出或输入可以直接索引到的暂 存器群组。更适当的是称他们为 “架构寄存器”。<br> 　　例如，x86 指令及定义八个 32 位元寄存器的集合，但一个实作 x86 指令集的 CPU 可以包含比八个更多的寄存器。<br> 　　寄存器是CPU内部的元件，寄存器拥有非常高的读写速度， 所以在寄存器之间的数据传送非常快。  </p><h2 id="寄存器用途"><a href="#寄存器用途" class="headerlink" title="寄存器用途"></a>寄存器用途</h2><p> 　　1.可将寄存器内的数据执行算术及逻辑运算；<br> 　　2.存于寄存器内的地址可用来指向内存的某个位置，即寻址；<br> 　　3.可以用来读写数据到电脑的周边设备。  </p><h2 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h2><p> 　　8086 有14个16位寄存器，这14个寄存器按其用途可分为(1) 通用寄存器、(2)指令指针、(3)标志寄存器和(4) 段寄存器等4类。<br>(1)通用寄存器有8个, 又可以分成2组,一组是数据寄存器(4个), 另一组是指针寄存器及变址寄存器(4个).<br> 　　数据寄存器分为:<br>AH&amp;AL＝AX(accumulator)：累加寄存器， 常用于运算;在乘除等指令中指定用来存放操作数,另外, 所有的I&#x2F;O指令都使用这一寄存器与外界设备传送数据.<br>BH&amp;BL＝BX(base)：基址寄存器，常用于地址索引；<br>CH&amp;CL＝CX(count)：计数寄存器，常用于计数； 常用于保存计算值,如在移位指令,循环(loop) 和串处理指令中用作隐含的计数器.<br>DH&amp;DL＝DX(data)：数据寄存器，常用于数据传递。<br> 　　他们的特点是,这4个16位的寄存器可以分为高8位: AH, BH, CH, DH.以及低八位：AL,BL,CL,DL。 这2组8位寄存器可以分别寻址，并单独使用。<br> 　　另一组是指针寄存器和变址寄存器，包括：<br>SP（Stack Pointer）：堆栈指针，与SS配合使用， 可指向目前的堆栈位置；<br>BP（Base Pointer）：基址指针寄存器， 可用作SS的一个相对基址位置；<br>SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针 ；<br>DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。<br> 　　这4个16位寄存器只能按16位进行存取操作， 主要用来形成操作数的地址， 用于堆栈操作和变址运算中计算操作数的有效地址。<br> 　　( 2) 指令指针IP(Instruction Pointer)<br> 　　指令指针IP是一个16位专用寄存器， 它指向当前需要取出的指令字节， 当BIU从内存中取出一个指令字节后，IP就自动加1， 指向下一个指令字节。注意， IP指向的是指令地址的段内地址偏移量，又称偏移地址( Offset Address)或有效地址(EA，Effective Address)。<br>(3)标志寄存器FR(Flag Register)<br> 　　8086有一个18位的标志寄存器FR， 在FR中有意义的有9位，其中6位是状态位，3位是控制位。<br>OF： 溢出标志位OF用于反映有符号数加减运算所得结果是否溢出。 如果运算结果超过当前运算位数所能表示的范围，则称为溢出， OF的值被置为1，否则，OF的值被清为0。<br>DF：方向标志DF位用来决定在串操作指令执行时有关指针寄存器发生调整的方向。<br>IF：中断允许标志IF位用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值， CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求， 以及CPU内部产生的中断请求。具体规定如下：<br> 　　(1)、当IF&#x3D;1时， CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br> 　　(2)、当IF&#x3D;0时， CPU不响应CPU外部的可屏蔽中断发出的中断请求。<br>TF：跟踪标志TF。该标志可用于程序调试。 TF标志没有专门的指令来设置或清楚。<br> 　　（1）如果TF&#x3D;1，则CPU处于单步执行指令的工作方式，会产生单步中断， 此时每执行完一条指令， 就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令 。<br> 　　（2）如果TF&#x3D;0，则处于连续工作模式。<br>SF：符号标志SF用来反映运算结果的符号位， 它与运算结果的最高位相同。在微机系统中， 有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。 运算结果为负数时，SF的值为1，非负时为0。<br>ZF： 零标志ZF用来反映运算结果是否为0。如果运算结果为0， 则其值为1，否则其值为0。在判断运算结果是否为0时， 可使用此标志位。<br>AF：下列情况下，辅助进位标志AF的值被置为1， 否则其值为0：<br> 　　(1)、在字操作时，发生低字节向高字节进位或借位时；<br> 　　(2)、在字节操作时，发生低4位向高4位进位或借位时。<br>PF：奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。 如果“1”的个数为偶数，则PF的值为1，否则其值为0。  CF：进位标志CF主要用来反映（无符号数）运算是否产生进位或借位。 如果运算结果的最高位产生了一个进位或借位，那么，其值为1， 否则其值为0。)<br>4)段寄存器(Segment Register)<br> 　　为了运用所有的内存空间，8086设定了四个段寄存器， 专门用来保存段地址：<br>CS（Code Segment）：代码段寄存器；<br>DS（Data Segment）：数据段寄存器；<br>SS（Stack Segment）：堆栈段寄存器；<br>ES（Extra Segment）：附加段寄存器。<br> 　　当一个程序要执行时，就要决定程序代码、 数据和堆栈各要用到内存的哪些位置，通过设定段寄存器 CS，DS，SS 来指向这些起始位置。通常是将DS固定，而根据需要修改CS。 所以，程序可以在可寻址空间小于64K的情况下被写成任意大小。 所以，程序和其数据组合起来的大小，限制在DS 所指的64K内，这就是COM文件不得大于64K的原因。 8086以内存做为战场，用寄存器做为军事基地，以加速工作。<br> 　　以上是8086寄存器的整体概况, 自80386开始，PC进入32bit时代，其寻址方式， 寄存器大小, 功能等都发生了变化：<br> 　　&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 以下是80386的寄存器的一些资料&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br> 寄存器都是32-bits宽。<br> 　　A、通用寄存器<br> 　　下面介绍通用寄存器及其习惯用法。顾名思义， 通用寄存器是那些你可以根据自己的意愿使用的寄存器， 修改他们的值通常不会对计算机的运行造成很大的影响。 通用寄存器最多的用途是计算。<br> 　　EAX：通用寄存器。相对其他寄存器，在进行运算方面比较常用。 在保护模式中，也可以作为内存偏移指针（此时，DS作为段 寄存器或选择器）<br> 　　EBX：通用寄存器。通常作为内存偏移指针使用（相对于EAX、 ECX、EDX），DS是默认的段寄存器或选择器。 在保护模式中，同样可以起这个作用。<br> 　　ECX：通用寄存器。通常用于特定指令的计数。在保护模式中， 也可以作为内存偏移指针（此时，DS作为 寄存器或段选择器）。<br> 　　EDX：通用寄存器。在某些运算中作为EAX的溢出寄存器（ 例如乘、除）。在保护模式中，也可以作为内存偏移指针（此时， DS作为段 寄存器或选择器）。<br> 　　同AX分为AH&amp;AL一样，上述寄存器包括对应的16- bit分组和8-bit分组。<br> 　　B、用作内存指针的特殊寄存器<br> 　　ESI：通常在内存操作指令中作为“源地址指针”使用。当然， ESI可以被装入任意的数值， 但通常没有人把它当作通用寄存器来用。 DS是默认段寄存器或选择器。<br> 　　EDI：通常在内存操作指令中作为“目的地址指针”使用。当然， EDI也可以被装入任意的数值， 但通常没有人把它当作通用寄存器来用。 DS是默认段寄存器或选择器。<br> 　　EBP：这也是一个作为指针的寄存器。通常， 它被高级语言编译器用以建造‘堆栈帧’ 来保存函数或过程的局部变量，不过，还是那句话， 你可以在其中保存你希望的任何数据。 SS是它的默认段寄存器或选择器。<br> 　　注意，这三个寄存器没有对应的8-bit分组。换言之， 你可以通过SI、DI、BP作为别名访问他们的低16位， 却没有办法直接访问他们的低8位。<br> 　　C、段选择器：<br> 　　实模式下的段寄存器到保护模式下摇身一变就成了选择器。 不同的是，实模式下的“段寄存器”是16-bit的， 而保护模式下的选择器是32-bit的。<br> 　　CS 代码段，或代码选择器。同IP寄存器(稍后介绍) 一同指向当前正在执行的那个地址。 处理器执行时从这个寄存器指向的段（实模式）或内存（保护模式） 中获取指令。除了跳转或其他分支指令之外， 你无法修改这个寄存器的内容。<br> 　　DS 数据段，或数据选择器。这个寄存器的低16 bit连同ESI一同指向的指令将要处理的内存。同时， 所有的内存操作指令 默认情况下都用它指定操作段(实模式)或内存(作为选择器， 在保护模式。这个寄存器可以被装入任意数值， 然而在这么做的时候需要小心一些。方法是，首先把数据送给AX， 然后再把它从AX传送给DS(当然，也可以通过堆栈来做).<br> 　　ES 附加段，或附加选择器。这个寄存器的低16 bit连同EDI一同指向的指令将要处理的内存。同样的， 这个寄存器可以被装入任意数值，方法和DS类似。<br> 　　FS F段或F选择器(推测F可能是Free?)。 可以用这个寄存器作为默认段寄存器或选择器的一个替代品。 它可以被装入任何数值，方法和DS类似。<br> 　　GS G段或G选择器(G的意义和F一样， 没有在Intel的文档中解释)。它和FS几乎完全一样。<br> 　　SS 堆栈段或堆栈选择器。这个寄存器的低16 bit连同ESP一同指向下一次堆栈操作(push和pop) 所要使用的堆栈地址。这个寄存器也可以被装入任意数值， 你可以通过入栈和出栈操作来给他赋值， 不过由于堆栈对于很多操作有很重要的意义，因此， 不正确的修改有可能造成对堆栈的破坏。  </p><p> 　　* 注意 一定不要在初学汇编的阶段把这些寄存器弄混。他们非常重要， 而一旦你掌握了他们，你就可以对他们做任意的操作了。段寄存器， 或选择器，在没有指定的情况下都是使用默认的那个。 这句话在现在看来可能有点稀里糊涂， 不过你很快就会在后面知道如何去做。<br> 　　指令指针寄存器：<br> 　　 　　 　　 EIP 这个寄存器非常的重要。这是一个32位宽的寄存器 ，同CS一同指向即将执行的那条指令的地址。 不能够直接修改这个寄存器的值， 修改它的唯一方法是跳转或分支指令。(CS是默认的段或选择器)<br> 　　* 上面是最基本的寄存器。下面是一些其他的寄存器， 你甚至可能没有听说过它们。(都是32位宽)：<br> 　　 CR0, CR2, CR3(控制寄存器)。举一个例子， CR0的作用是切换实模式和保护模式。<br> 　　 　　 　　 还有其他一些寄存器，D0, D1, D2, D3, D6和D7(调试寄存器)。 他们可以作为调试器的硬件支持来设置条件断点。 TR3, TR4, TR5, TR6 和 TR? 寄存器(测试寄存器)用于某些条件测试</p><p>总结</p><p> 4个数据寄存器(EAX、EBX、ECX和EDX)<br> 2个变址和指针寄存器(ESI和EDI) 2个指针寄存器(ESP和EBP)<br> 6个段寄存器(ES、CS、SS、DS、FS和GS)<br> 1个指令指针寄存器(EIP) 1个标志寄存器(EFlags)</p><p> 1、数据寄存器<br>  数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。</p><p> 4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种”可分可合”的特性，灵活地处理字&#x2F;字节的信息。</p><p>寄存器AX和AL通常称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。累加器可用于乘、  除、输入&#x2F;输出等操作，它们的使用频率很高； 寄存器BX称为基地址寄存器(Base Register)。它可作为存储器指针来使用；  寄存器CX称为计数寄存器(Count Register)。在循环和字符串操作时，要用它来控制循环次数；在位操作  中，当移多位时，要用CL来指明移位的位数；<br> 寄存器DX称为数据寄存器(Data  Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I&#x2F;O的端口地址。在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。</p><p>2、变址寄存器<br> 32位CPU有2个32位通用寄存器ESI和EDI。其低16位对应先前CPU中的SI和DI，对低16位数据的存取，不影响高16位的数据。<br>寄存器ESI、EDI、SI和DI称为变址寄存器(Index  Register)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。<br>3、指针寄存器<br> 32位CPU有2个32位通用寄存器EBP和ESP。其低16位对应先前CPU中的SBP和SP，对低16位数据的存取，不影响高16位的数据。（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。寄存器EBP、ESP、BP和SP称为指针寄存器(Pointer  Register)，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。<br>它们主要用于访问堆栈内的存储单元，并且规定：<br>BP为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据；<br>SP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。<br>4、段寄存器<br> 段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成<br> 的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。<br> CPU内部的段寄存器：<br> CS——代码段寄存器(Code Segment Register)，其值为代码段的段值；<br> DS——数据段寄存器(Data Segment Register)，其值为数据段的段值；<br> ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；<br> SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值；<br> FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；<br> GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。</p><p>  在16位CPU系统中，它只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。32位CPU有两个不同的工作方式：实方式和保护方式。在每种方式下，段寄存器的作用是不同的。有关规定简单描述如下：<br> 实方式： 前4个段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致，内存单元的逻辑地址仍为”段值：偏移量”的形式。为访问某内存段内的数据，必须使用该段寄存器和存储单元的偏移量。<br> 保护方式： 在此方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为”选择子”(Selector)的某个值。<br> 5、指令指针寄存器<br> 32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。<br> 指令指针EIP、IP(Instruction Pointer)是存放下次将要执行的指令在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。<br> 在实方式下，由于每个段的最大范围为64K，所以，EIP中的高16位肯定都为0，此时，相当于只用其低16位的IP来反映程序中指令的执行次序。<br> 6、标志寄存器<br> 一、运算结果标志位<br> 1、进位标志CF(Carry Flag)<br> 进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。<br> 2、奇偶标志PF(Parity Flag)<br> 奇偶标志PF用于反映运算结果中”1″的个数的奇偶性。如果”1″的个数为偶数，则PF的值为1，否则其值为0。<br> 利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。<br> 3、辅助进位标志AF(Auxiliary Carry Flag)<br> 在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<br> (1)、在字操作时，发生低字节向高字节进位或借位时；<br> (2)、在字节操作时，发生低4位向高4位进位或借位时。<br> 对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。<br> 4、零标志ZF(Zero Flag)<br> 零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br> 5、符号标志SF(Sign Flag)<br> 符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。<br> 6、溢出标志OF(Overflow Flag)<br>  溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。”溢出”和”进位”是两个不同含义的概念，不要混淆。如果不太清楚的话，请查阅《计算机组成原理》课程中的有关章节。<br> 二、状态控制标志位<br> 状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。<br> 1、追踪标志TF(Trap Flag)<br> 当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。<br> 2、中断允许标志IF(Interrupt-enable Flag)<br> 中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：<br> (1)、当IF&#x3D;1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br> (2)、当IF&#x3D;0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。<br> CPU的指令系统中也有专门的指令来改变标志位IF的值。<br> 3、方向标志DF(Direction Flag)<br> 方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节——字符串操作指令——中给出。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。<br> 三、32位标志寄存器增加的标志位<br> 1、I&#x2F;O特权标志IOPL(I&#x2F;O Privilege Level)<br> I&#x2F;O特权标志用两位二进制位来表示，也称为I&#x2F;O特权级字段。该字段指定了要求执行I&#x2F;O指令的特权级。如果当前的特权级别在数值上小于等于IOPL的值，那么，该I&#x2F;O指令可执行，否则将发生一个保护异常。<br> 2、嵌套任务标志NT(Nested Task)<br> 嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下：<br> (1)、当NT&#x3D;0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作；<br> (2)、当NT&#x3D;1，通过任务转换实现中断返回。<br> 3、重启动标志RF(Restart Flag)<br> 重启动标志RF用来控制是否接受调试故障。规定：RF&#x3D;0时，表示”接受”调试故障，否则拒绝之。在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1。<br> 4、虚拟8086方式标志VM(Virtual 8086 Mode)<br> 如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;寄存器&lt;/p&gt;
&lt;p&gt;英文名称：Register&lt;/p&gt;
&lt;h2 id=&quot;寄存器定义&quot;&gt;&lt;a href=&quot;#寄存器定义&quot; class=&quot;headerlink&quot; title=&quot;寄存器定义&quot;&gt;&lt;/a&gt;寄存器定义&lt;/h2&gt;&lt;p&gt; 　　寄存器是 &lt;a href=&quot;http://ba</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>windows核心编程</title>
    <link href="http://example.com/2023/03/27/windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2023/03/27/windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</id>
    <published>2023-03-27T14:38:53.168Z</published>
    <updated>2023-04-14T01:36:02.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量属性表示"><a href="#变量属性表示" class="headerlink" title="变量属性表示"></a>变量属性表示</h1><p>全局变量g_</p><p>常量c_</p><p>结构体字段、类成员变量m_(member)</p><p>静态变量s_</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202304140935394.png" alt="属性变量表示"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;变量属性表示&quot;&gt;&lt;a href=&quot;#变量属性表示&quot; class=&quot;headerlink&quot; title=&quot;变量属性表示&quot;&gt;&lt;/a&gt;变量属性表示&lt;/h1&gt;&lt;p&gt;全局变量g_&lt;/p&gt;
&lt;p&gt;常量c_&lt;/p&gt;
&lt;p&gt;结构体字段、类成员变量m_(member)&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>汇编学习</title>
    <link href="http://example.com/2023/03/27/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/03/27/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-27T14:38:12.301Z</published>
    <updated>2023-08-01T04:42:02.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、汇编语言是什么？"><a href="#一、汇编语言是什么？" class="headerlink" title="一、汇编语言是什么？"></a>一、汇编语言是什么？</h2><p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p><p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html">编译器</a>的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p><p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p><p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p><h2 id="二、来历"><a href="#二、来历" class="headerlink" title="二、来历"></a>二、来历</h2><p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p><p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。</p><p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做  assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为  asm，中文译为汇编语言。每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p><h2 id="三、寄存器"><a href="#三、寄存器" class="headerlink" title="三、寄存器"></a>三、寄存器</h2><p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p><p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU  的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p><p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU  还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU  优先读写寄存器，再由寄存器跟内存交换数据。</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281441087.png" alt="image-20230328144102980"></p><p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p><h2 id="四、寄存器的种类"><a href="#四、寄存器的种类" class="headerlink" title="四、寄存器的种类"></a>四、寄存器的种类</h2><p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。一般寄存器:AX、BX、CX、DX，索引暂存器:SI、DI，堆叠、基底暂存器:SP、BP。EAX、ECX、EDX、EBX：为ax,bx,cx,dx的延伸，各为32位元<br>ESI、EDI、ESP、EBP：为si,di,sp,bp的延伸，32位元。eax, ebx, ecx, edx, esi, edi, ebp, esp等都是X86 汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。如果用C语言来解释，可以把这些寄存器当作变量看待。</p><p>这些32位寄存器有多种用途，但每一个都有“专长”，有各自的特别之处。</p><p>EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。</p><p>EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址。</p><p>ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。</p><p>EDX 则总是被用来放整数除法产生的余数。</p><p>ESI&#x2F;EDI分别叫做”源&#x2F;目标索引寄存器”(source&#x2F;destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.</p><blockquote><p>​push ebp ;保存当前ebp<br>　mov ebp,esp ;EBP设为当前堆栈指针<br>　sub esp, xxx ;预留xxx字节给函数临时变量.<br>　…　　</p></blockquote><p>这样一来,EBP 构成了该函数的一个框架, 在EBP上方分别是原来的EBP, 返回地址和参数. EBP下方则是临时变量. 函数返回时作 mov esp,ebp&#x2F;pop ebp&#x2F;ret 即可.</p><p>ESP 专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。</p><p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p><h2 id="五、内存模型：Heap"><a href="#五、内存模型：Heap" class="headerlink" title="五、内存模型：Heap"></a>五、内存模型：Heap</h2><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281451635.png" width="40%"><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281500821.png" width="40%/"><p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h2 id="六、内存模型：Stack"><a href="#六、内存模型：Stack" class="headerlink" title="六、内存模型：Stack"></a>六、内存模型：Stack</h2><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281502145.png" width="40%/"><p>请看下面的例子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clike">int main() &#123;<br>   int a = 2;<br>   int b = 3;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281503456.png" width="40%"><p>如果函数内部调用了其他函数，会发生什么情况？</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clike">int main() &#123;<br>   int a = 2;<br>   int b = 3;<br>   return add_a_and_b(a, b);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281504175.png" width="40%"><p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是  push；栈的回收叫做”出栈”，英文是 pop。Stack  的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303281505057.png" width="40%"><h2 id="七、CPU-指令"><a href="#七、CPU-指令" class="headerlink" title="七、CPU 指令"></a>七、CPU 指令</h2><h3 id="7-1-一个实例"><a href="#7-1-一个实例" class="headerlink" title="7.1 一个实例"></a>7.1 一个实例</h3><p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clike">int add_a_and_b(int a, int b) &#123;<br>   return a + b;<br>&#125;<br><br>int main() &#123;<br>   return add_a_and_b(2, 3);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>gcc 将这个程序转成汇编语言。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -S example.c<br></code></pre></td></tr></table></figure></blockquote><p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p><p><code>example.s</code>经过简化以后，大概是下面的样子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clike">_add_a_and_b:<br>push   %ebx//esp-4<br>mov    %eax, [%esp+8]// 取2<br>mov    %ebx, [%esp+12]// 取3<br>add    %eax, %ebx//a+b值存在eax中<br>pop    %ebx//ebx弹出栈，esp+4<br>ret//退出程序执行<br><br>_main:<br>push   3//压栈，整型占4字节，esp栈顶指针-4<br>push   2//压栈，esp-4<br>call   _add_a_and_b//调用add函数<br>add    %esp, 8 //esp+8 保存在esp中<br>ret//退出程序执行<br></code></pre></td></tr></table></figure></blockquote><p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p><p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   %ebx<br></code></pre></td></tr></table></figure></blockquote><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p><h3 id="7-2-push-指令"><a href="#7-2-push-指令" class="headerlink" title="7.2 push 指令"></a>7.2 push 指令</h3><p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p><p>然后，开始执行第一行代码。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   3<br></code></pre></td></tr></table></figure></blockquote><p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p><p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   2<br></code></pre></td></tr></table></figure></blockquote><p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012216.png" alt="img"></p><h3 id="7-3-call-指令"><a href="#7-3-call-指令" class="headerlink" title="7.3 call 指令"></a>7.3 call 指令</h3><p>第三行的<code>call</code>指令用来调用函数。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">call   _add_a_and_b<br></code></pre></td></tr></table></figure></blockquote><p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p><p>下面就开始执行<code>_add_a_and_b</code>的代码。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">push   %ebx<br></code></pre></td></tr></table></figure></blockquote><p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p><p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p><h3 id="7-4-mov-指令"><a href="#7-4-mov-指令" class="headerlink" title="7.4 mov 指令"></a>7.4 mov 指令</h3><p><code>mov</code>指令用于将一个值写入某个寄存器。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">mov    %eax, [%esp+8] <br></code></pre></td></tr></table></figure></blockquote><p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p><p>下一行代码也是干同样的事情。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">mov    %ebx, [%esp+12] <br></code></pre></td></tr></table></figure></blockquote><p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p><h3 id="7-5-add-指令"><a href="#7-5-add-指令" class="headerlink" title="7.5 add 指令"></a>7.5 add 指令</h3><p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">add    %eax, %ebx<br></code></pre></td></tr></table></figure></blockquote><p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p><h3 id="7-6-pop-指令"><a href="#7-6-pop-指令" class="headerlink" title="7.6 pop 指令"></a>7.6 pop 指令</h3><p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">pop    %ebx<br></code></pre></td></tr></table></figure></blockquote><p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p><p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p><h3 id="7-7-ret-指令"><a href="#7-7-ret-指令" class="headerlink" title="7.7 ret 指令"></a>7.7 ret 指令</h3><p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">ret<br></code></pre></td></tr></table></figure></blockquote><p>可以看到，该指令没有运算子。</p><p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">add    %esp, 8 <br></code></pre></td></tr></table></figure></blockquote><p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clike">ret<br></code></pre></td></tr></table></figure></blockquote><p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p><hr><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span> <span class="hljs-built_in">bx</span> //取<span class="hljs-built_in">bx</span>寄存器的值送到<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span> <span class="hljs-number">18</span> //<span class="hljs-built_in">ax</span> = <span class="hljs-number">18</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span> <span class="hljs-built_in">bx</span> //<span class="hljs-built_in">ax</span> = <span class="hljs-built_in">ax</span>+<span class="hljs-built_in">bx</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span> <span class="hljs-number">7</span> //<span class="hljs-built_in">ax</span> = <span class="hljs-built_in">ax</span>+<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>字节：记为byte，一个字节由8个bit组成。</p><p>字：记为word，一个字由两个字节组成，这两个字节分别成为这个字的高位字节和低位字节。</p><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><h3 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h3><p>机器语言是0101，汇编语言是机器语言的助记符，每种cpu都有自己的汇编指令集。</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241624754.png" alt="image-20230724162413568"></p><h3 id="1-2-单位"><a href="#1-2-单位" class="headerlink" title="1.2 单位"></a>1.2 单位</h3><p>1Byte(B) &#x3D; 8 bit, 1 Word &#x3D; 2 Byte,  1KB &#x3D; 1024 B, 1 MB &#x3D; 1024 KB, 1 GB &#x3D; 1024 MB, 1 TB &#x3D; 1024GB</p><p>DW 是定义2字节空间的意思。DW属于汇编的一个伪指令，DW定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2。</p><p>DB定义字节类型变量，一个字节数据占1个字节单元，读完一个，偏移量加1。</p><p>DD定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4。</p><p>基本数据度量单位:<br>1 BYTE(字节)&#x3D; 8 BIT(比特)<br>WORD&#x3D;2BYTE&#x3D;16BIT<br>DWORD&#x3D; 4 BYTE &#x3D; 32 BIT<br>QWORD&#x3D; 8BYTE &#x3D; 64 BIT<br>数据存储度量单位:<br>1KB&#x3D; 1024 BYTE &#x3D; 8192 BIT<br>1MB &#x3D; 1024KB<br>1GB &#x3D; 1024MB<br>1TB &#x3D; 1024GB</p><p>取值范围:<br>BYTE&#x3D;有符号:-128至127|无符号:0至255<br>WORD &#x3D;有符号: -32768 至32767 |无符号: 0至65535<br>DWORD &#x3D;有符号: -2,147 ,483,648至2, 147 ,483,647|无符号: 0至4,294,967 ,295<br>QWORD&#x3D;有符号: -9,223,372,036,854,775,808 至9,223,372,036,854,775 807</p><h3 id="1-3-CPU-对存储器的读写"><a href="#1-3-CPU-对存储器的读写" class="headerlink" title="1.3 CPU 对存储器的读写"></a>1.3 CPU 对存储器的读写</h3><p>1.地址总线  2.数据总线 3.控制总线  4.I&#x2F;O总线</p><p>地址总线的宽度决定了cpu的寻址能力，数据总线的宽度决定了cpu与其他器件进行数据传输时的一次数据传输量；控制总线的宽度决定了cpu对系统中其他器件的控制能力。</p><h3 id="1-4-各存储器芯片"><a href="#1-4-各存储器芯片" class="headerlink" title="1.4 各存储器芯片"></a>1.4 各存储器芯片</h3><p>存储器都与cpu的主线相连，cpu对他们进行读或写的时候通过控制线发出读写命令。</p><ul><li>随机存储器</li></ul><p>用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展插槽上的RAM。</p><ul><li>装有BIOS(Basic Input&#x2F;Output System，基本输入&#x2F;输出系统)的ROM</li></ul><p>BIOS是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。例如，主板上的ROM中存储着主板的BIOS(通常称为系统BIOS);显卡上的ROM中存储着显卡的BIOS;如果网卡上装有ROM，那其中就可以存储网卡的BIOS。</p><ul><li>接口卡上的RAM</li></ul><p>某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM。最典型的是显示卡上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。</p><h2 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2.寄存器"></a>2.寄存器</h2><p><strong>x86&#x2F;x64架构</strong>的CPU中的寄存器</p><h3 id="2-1-什么是寄存器？"><a href="#2-1-什么是寄存器？" class="headerlink" title="2.1 什么是寄存器？"></a>2.1 什么是寄存器？</h3><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果以及一些CPU运行需要的信息。</p><p>x86架构CPU走的是<strong>复杂指令集（CISC）</strong> 路线，提供了丰富的指令来实现强大的功能，与此同时也提供了大量寄存器来辅助功能实现。</p><h3 id="2-2通用寄存器"><a href="#2-2通用寄存器" class="headerlink" title="2.2通用寄存器"></a>2.2通用寄存器</h3><p>首先是通用寄存器，这些的寄存器是程序执行代码最最常用，也最最基础的寄存器，程序执行过程中，绝大部分时间都是在操作这些寄存器来实现指令功能。</p><p>所谓通用，即这些寄存器CPU没有特殊的用途，交给应用程序“随意”使用。注意，这个随意，我打了引号，对于有些寄存器，CPU有一些潜规则，用的时候要注意。</p><ul><li><strong>eax</strong>: 通常用来执行加法，函数调用的返回值一般也放在这里面</li><li><strong>ebx</strong>: 数据存取</li><li><strong>ecx</strong>: 通常用来作为计数器，比如for循环</li><li><strong>edx</strong>: 读写I&#x2F;O端口时，edx用来存放端口号</li><li><strong>esp</strong>: 栈顶指针，指向栈的顶部</li><li><strong>ebp</strong>: 栈底指针，指向栈的底部，通常用<code>ebp+偏移量</code>的形式来定位函数存放在栈中的局部变量</li><li><strong>esi</strong>: 字符串操作时，用于存放数据源的地址</li><li><strong>edi</strong>: 字符串操作时，用于存放目的地址的，和esi两个经常搭配一起使用，执行字符串的复制等操作</li></ul><p>在x64架构中，上面的通用寄存器都扩展成为64位版本，名字也进行了升级。当然，为了兼容32位模式程序，使用上面的名字仍然是可以访问的，相当于访问64位寄存器的低32位。</p><blockquote><p>rax rbx rcx rdx rsp rbp rsi rdi</p></blockquote><p>除了扩展原来存在的通用寄存器，x64架构还引入了8个新的通用寄存器：</p><blockquote><p><strong>r8-r15</strong></p></blockquote><p>在原来32位时代，函数调用时，那个时候通用寄存器少，参数绝大多数时候是通过线程的栈来进行传递（当然也有使用寄存器传递的，比如著名的C++ <strong>this指针</strong>使用ecx寄存器传递，不过能用的寄存器毕竟不多）。</p><p>进入x64时代，寄存器资源富裕了，参数传递绝大多数都是用寄存器来传了。<strong>寄存器传参的好处是速度快，减少了对内存的读写次数。</strong></p><p>当然，具体使用栈还是用寄存器传参数，这个不是编程语言决定的，而是编译器在编译生成CPU指令时决定的，如果编译器非要在x64架构CPU上使用线程栈来传参那也不是不行，这个对高级语言是无感知的。</p><h3 id="2-2标志寄存器"><a href="#2-2标志寄存器" class="headerlink" title="2.2标志寄存器"></a>2.2标志寄存器</h3><p>标志寄存器，里面有众多标记位，记录了CPU执行指令过程中的一系列状态，这些标志大都由CPU自动设置和修改：</p><ul><li>CF 进位标志（1进0不进）</li><li>PF 奇偶标志（1的个数为偶数是1，否则为0）</li><li>ZF 零标志（0为1）</li><li>SF 符号标志（有符号数，负数为1）</li><li>OF 补码溢出标志（1溢出，0不溢出）</li><li>TF 跟踪标志（1为单步状态，0为正常状态）</li><li>IF 中断标志（允许处理可屏蔽中断为1）</li><li>······</li></ul><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241653434.png" alt="image-20230724165348353"></p><p>在x64架构下，原来的eflags寄存器升级为64位的rflags，不过其高32位并没有新增什么功能，保留为将来使用。</p><h3 id="2-3-指令寄存器"><a href="#2-3-指令寄存器" class="headerlink" title="2.3 指令寄存器"></a>2.3 指令寄存器</h3><blockquote><p><strong>eip</strong>: 指令寄存器可以说是CPU中最最重要的寄存器了，它指向了下一条要执行的指令所存放的地址，CPU的工作其实就是不断取出它指向的指令，然后执行这条指令，同时指令寄存器继续指向下面一条指令，如此不断重复，这就是CPU工作的基本日常。</p></blockquote><p>而在漏洞攻击中，黑客想尽办法费尽心机都想要修改指令寄存器的地址，从而能够执行恶意代码。</p><p>同样的，在x64架构下，32位的eip升级为64位的<strong>rip</strong>寄存器。</p><h3 id="2-4-段寄存器"><a href="#2-4-段寄存器" class="headerlink" title="2.4 段寄存器"></a>2.4 段寄存器</h3><p>段寄存器与CPU的内存寻址技术紧密相关。</p><p>早在16位的8086CPU时代，内存资源宝贵，CPU使用分段式内存寻址技术：</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241656064.png" alt="image-20230724165637000"></p><p>16位的寄存器能寻址的范围是64KB，通过引入段的概念，将内存空间划分为不同的区域：分段，通过段基址+段内偏移段方式来寻址。</p><p>这样一来，段的基地址保存在哪里呢？8086CPU专门设置了几个段寄存器用来保存段的基地址，这就是段寄存器段的由来。</p><p>段寄存器也是16位的。</p><p>段寄存器有下面6个，前面4个是早期16位模式就引入了，到了32位时代，又新增了fs和gs两个段寄存器。</p><ul><li><strong>cs</strong>: 代码段</li><li><strong>ds</strong>: 数据段</li><li><strong>ss</strong>: 栈段</li><li><strong>es</strong>: 扩展段</li><li><strong>fs</strong>: 数据段</li><li><strong>gs</strong>: 数据段</li></ul><p>段寄存器里面存储的内容与CPU当前工作的内存寻址模式紧密相关。</p><p>当CPU处于16位实地址模式下时，段寄存器存储段的基地址，寻址时，将段寄存器内容左移4位（乘以16）得到段基地址+段内偏移得到最终的地址。</p><p>当CPU工作于保护模式下，段寄存器存储的内容不再是段基址了，此时的段寄存器中存放的是<strong>段选择子</strong>，用来指示当前这个段寄存器“指向”的是哪个分段。</p><p>注意我这里的指向打了引号，段寄存器中存储的并不是内存段的直接地址，而是段选择子，它的结构如下：</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241657443.png" alt="image-20230724165705393"></p><p>16个bit长度的段寄存器内容划分了三个字段：</p><ul><li><strong>PRL</strong>: 特权请求级，就是我们常说的ring0-ring3四个特权级。</li><li><strong>TI</strong>: 0表示用的是全局描述符表GDT，1表示使用的是局部描述符表LDT。</li><li><strong>Index</strong>: 这是一个表格中表项的索引值，这个表格叫<strong>内存描述符表</strong>，它的每一个表项都描述了一个内存分段。</li></ul><p>这里提到了两个表，全局描述符表GDT和局部描述符表LDT，关于这两个表的介绍，下面介绍描述符寄存器时再详述，这里只需要知道，这是CPU支持分段式内存管理需要的表格，放在内存中，表格中的每一项都是一个描述符，记录了一个内存分段的信息。</p><p>保护模式下的段寄存器和段描述符到最后的内存分段，通过下图的方式联系在一起：</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241658819.png" alt="image-20230724165837724"></p><p>通用寄存器、段寄存器、标志寄存器、指令寄存器，这四组寄存器共同构成了一个基本的指令执行环境，一个线程的上下文也基本上就是这些寄存器，在执行线程切换的时候，就是修改它们的内容。</p><h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>控制寄存器是CPU中一组相当重要的寄存器，我们知道eflags寄存器记录了当前运行线程的一系列关键信息。</p><p>那CPU运行过程中自身的一些关键信息保存在哪里呢？答案是控制寄存器！</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241659028.png" alt="image-20230724165946931"></p><p>32位CPU总共有cr0-cr4共5个控制寄存器，64位增加了cr8。他们各自有不同的功能，但都存储了CPU工作时的重要信息：</p><ul><li><strong>cr0</strong>: 存储了CPU控制标记和工作状态</li><li><strong>cr1</strong>: 保留未使用</li><li><strong>cr2</strong>: 页错误出现时保存导致出错的地址</li><li><strong>cr3</strong>: 存储了当前进程的虚拟地址空间的重要信息——<strong>页目录</strong>地址</li><li><strong>cr4</strong>: 也存储了CPU工作相关以及当前人任务的一些信息</li><li><strong>cr8</strong>: 64位新增扩展使用</li></ul><p>其中，CR0尤其重要，它包含了太多重要的CPU信息，值得单独关注一下：</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241701514.png" alt="image-20230724170117455"></p><p>一些重要的标记位含义如下：</p><p><code>PG</code>: 是否启用内存分页</p><p><code>AM</code>: 是否启用内存对齐自动检查</p><p><code>WP</code>: 是否开启内存写保护，若开启，对只读页面尝试写入时将触发异常，这一机制常常被用来实现<strong>写时复制</strong>功能</p><p><code>PE</code>: 是否开启保护模式</p><p>除了CR0，另一个值得关注的寄存器是CR3，它保存了当前进程所使用的虚拟地址空间的页目录地址，可以说是整个虚拟地址翻译中的顶级指挥棒，在进程空间切换的时候，CR3也将同步切换。</p><h2 id="调试寄存器"><a href="#调试寄存器" class="headerlink" title="调试寄存器"></a>调试寄存器</h2><p>在x86&#x2F;x64CPU内部，还有一组用于支持软件调试的寄存器。</p><p>调试，对于我们程序员是家常便饭，必备技能。但你想过你的程序能够被调试背后的原理吗？</p><p>程序能够被调试，关键在于能够被中断执行和恢复执行，被中断的地方就是我们设置的断点。那程序是如何能在遇到断点的时候停下来呢？</p><p>对于一些解释执行（PHP、Python、JavaScript）或虚拟机执行（Java）的高级语言，这很容易办到，因为它们的执行都在解释器&#x2F;虚拟机的掌控之中。</p><p>而对于像C、C++这样的“底层”编程语言，程序代码是直接编译成CPU的机器指令来执行的，这就需要CPU来提供对于调试的支持了。</p><p>对于通常的断点，也就是程序执行到某个位置下就停下来，这种断点实现的方式，在x86&#x2F;x64上，是利用了一条<strong>软中断</strong>指令：<strong>int 3</strong>来进行实现的。</p><p>注意，这里的<strong>int</strong>不是指高级语言里面的整数，而是表示interrupt中断的意思，是一条汇编指令，int 3则表示中断向量号为3的中断。</p><p>在我们使用调试器下断点时，调试器将会把对应位置的原来的指令替换为一个int 3指令，机器码为0xCC。这个动作对我们是透明的，我们在调试器中看到的依然是原来的指令，但实际上内存中已经不是原来的指令了。</p><p>顺便提一句，两个0xCC是汉字【烫】的编码，在一些编译器里，会给线程的栈中填充大量的0xCC，如果程序出错的时候，我们经常会看到很多<strong>烫烫烫</strong>出现，就是这个原因。</p><p>言归正传，CPU在执行这条int 3指令时，将自动触发中断处理流程（虽然这实际上不是一个真正的中断），CPU将取出IDTR寄存器指向的中断描述符表IDT的第3项，执行里面的中断处理函数。</p><p>而这个中断描述符表，早在操作系统启动之初，就已经提前安排好了，所以执行这条指令后，操作系统的中断处理函数将介入，来处理这一事件。</p><p>后面的过程就多了，简单来说，操作系统会把触发这一事件的进程冻结起来，随后将这一事件发送到调试器，调试器拿到之后就知道目标进程触发断点了。这个时候，咱们程序员就能通过调试器的UI交互界面或者命令行调试接口来调试目标进程，查看堆栈、查看内存、变量都随你。</p><p>如果我们要继续运行，调试器将会把之前修改的int 3指令给恢复回去，然后告知操作系统：我处理完了，把目标进程解冻吧！</p><p>上面简单描述了一下普通断点的实现原理。现在思考一个场景：我们发现一个bug，某个全局整数型变量的值老是莫名其妙被修改，但你发现有很多线程，很多函数都有可能会去修改这个变量，你想找出到底谁干的，怎么办？</p><p>这个时候上面的普通断点就没办法了，你需要一种新的断点：<strong>硬件断点</strong>。</p><p>这时候就该调试寄存器登场表演了。</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241703503.png" alt="image-20230724170358424"></p><p>在x86架构CPU内部，提供了8个调试寄存器DR0~DR7。</p><p><strong>DR0~DR3</strong>：这是四个用于存储地址的寄存器</p><p><strong>DR4~DR5</strong>：这两个有点特殊，受前面提到的CR4寄存器中的标志位DE位控制，如果CR4的DE位是1，则DR4、DR5是不可访问的，访问将触发异常。如果CR4的DE位是0，则DR4和DR5将会变成DR6和DR7的别名，相当于做了一个软链接。这样做是为了将DR4、DR5保留，以便将来扩展调试功能时使用。</p><p><strong>DR6</strong>：这个寄存器中存储了硬件断点触发后的一些状态信息</p><p><strong>DR7</strong>：调试控制寄存器，这里面记录了对DR0-DR3这四个寄存器中存储地址的中断方式（是对地址的读，还是写，还是执行）、数据长度（1&#x2F;2&#x2F;4个字节）以及作用范围等信息</p><p>通过调试器的接口设置硬件断点后，CPU在执行代码的过程中，如果满足条件，将自动中断下来。</p><p>回答前面提出的问题，想要找出是谁偷偷修改了全局整形变量，只需要通过调试器设置一个硬件写入断点即可。</p><h3 id="描述符寄存器"><a href="#描述符寄存器" class="headerlink" title="描述符寄存器"></a>描述符寄存器</h3><p>所谓<strong>描述符</strong>，其实就是一个数据结构，用来记录一些信息，‘描述’一个东西。把很多个描述符排列在一起，组成一个表，就成了描述符表。再使用一个寄存器来指向这个表，这个寄存器就是<strong>描述符寄存器</strong>。</p><p>在x86&#x2F;x64系列CPU中，有三个非常重要的描述符寄存器，它们分别存储了三个地址，指向了三个非常重要的描述符表。</p><p><code>gdtr</code>: 全局描述符表寄存器，前面提到，CPU现在使用的是段+分页结合的内存管理方式，那系统总共有那些分段呢？这就存储在一个叫全局描述符表（<strong>GDT</strong>）的表格中，并用gdtr寄存器指向这个表。这个表中的每一项都描述了一个内存段的信息。</p><p><code>ldtr</code>: 局部描述符表寄存器，这个寄存器和上面的gdtr一样，同样指向的是一个段描述符表（<strong>LDT</strong>）。不同的是，GDT是全局唯一，LDT是局部使用的，可以创建多个，随着任务段切换而切换（下文介绍任务寄存器会提到）。</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241704250.png" alt="image-20230724170435177"></p><p>GDT和LDT中的表项，就是段描述符，描述了一个内存分段的信息，其结构如下：</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241704111.png" alt="image-20230724170448034"></p><p>一个表项占据8个字节（32位CPU），里面存储了一个内存分段的诸多信息：基地址、大小、权限、类型等信息。</p><p>除了这两个段描述符寄存器，还有一个非常重要的描述符寄存器：</p><p><code>idtr</code>: 中断描述符表寄存器，指向了<strong>中断描述符表IDT</strong>，这个表的每一项都是一个中断处理描述符，当CPU执行过程中发生了硬中断、异常、软中断时，将自动从这个表中定位对应的表项，里面记录了发生中断、异常时该去哪里执行处理函数。</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241705170.png" alt="image-20230724170521092"></p><p>IDT中的表项称为<strong>Gate</strong>，中文意思为<strong>门</strong>，因为这是应用程序进入内核的主要入口。虽然表的名字叫中断描述符表，但表中存储的不全是中断描述符，IDT中的表项存在三种类型，对应三种类型的门：</p><ul><li><strong>任务门</strong></li><li><strong>陷阱门</strong></li><li><strong>中断门</strong></li></ul><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241705976.png" alt="image-20230724170544891"></p><p>三种描述符中都存储了处理这个中断&#x2F;异常&#x2F;任务时该去哪里处理的地址。三种门用途不一，其中中断门是真正意义上的中断，而像前面提到的调试指令int 3以及老式的系统调用指令int 2e&#x2F;int 80都属于陷阱门。任务门则用的较少，要了解任务门，先了解下任务寄存器。</p><h3 id="任务寄存器"><a href="#任务寄存器" class="headerlink" title="任务寄存器"></a>任务寄存器</h3><p>现代操作系统，都是支持多任务并发运行的，x86架构CPU为了顺应时代潮流，在硬件层面上提供了专门的机制用来支持多任务的切换，这体现在两个方面：</p><ul><li>CPU内部设置了一个专用的寄存器——<strong>任务寄存器TR</strong>，它指向当前运行的任务。</li></ul><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241706350.png" alt="image-20230724170626282"></p><p>定义了描述任务的数据结构<strong>TSS</strong>，里面存储了一个任务的上下文（一系列寄存器的值），下图是一个32位CPU的TSS结构图：</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241707552.png" alt="image-20230724170748458"></p><p>x86CPU的构想是每一个任务对应一个TSS，然后由TR寄存器指向当前的任务，执行任务切换时，修改TR寄存器的指向即可，这是硬件层面的多任务切换机制。</p><p>这个构想其实还是很不错的，然而现实却打了脸，包括Linux和Windows在内的主流操作系统都没有使用这个机制来进行线程切换，而是自己使用软件来实现多线程切换。</p><p>所以，绝大多数情况下，TR寄存器都是指向固定的，即便线程切换了，TR寄存器仍然不会变化。</p><p>注意，我这里说的的是绝大多数情况，而没有说死。虽然操作系统不依靠TSS来实现多任务切换，但这并不意味着CPU提供的TSS操作系统一点也没有使用。还是存在一些特殊情况，如一些异常处理会使用到TSS来执行处理。</p><p>下面这张图，展示了控制寄存器、描述符寄存器、任务寄存器构成的全貌：</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202307241708313.png" alt="image-20230724170828192"></p><h3 id="模型特定寄存器"><a href="#模型特定寄存器" class="headerlink" title="模型特定寄存器"></a>模型特定寄存器</h3><p>从80486之后的x86架构CPU，内部增加了一组新的寄存器，统称为<strong>MSR寄存器</strong>，中文直译是模型特定寄存器，意思是这些寄存器不像上面列出的寄存器是固定的，这些寄存器可能随着不同的版本有所变化。这些寄存器主要用来支持一些新的功能。</p><p>随着x86CPU不断更新换代，MSR寄存器变的越来越多，但与此同时，有一部分MSR寄存器随着版本迭代，慢慢固化下来，成为了变化中那部分不变的，这部分MSR寄存器，Intel将其称为Architected MSR，这部分MSR寄存器，在命名上，统一加上了<strong>IA32</strong>的前缀。</p><p>这里选取三个代表性的MSR简单介绍一下：</p><ul><li>IA32_SYSENTER_CS</li><li>IA32_SYSENTER_ESP</li><li>IA32_SYSENTER_EIP</li></ul><p>这三个MSR寄存器是用来实现<strong>快速系统调用</strong>。</p><p>在早期的x86架构CPU上，系统调用依赖于软中断实现，类似于前面调试用到的int 3指令，在Windows上，系统调用用到的是<strong>int 2e</strong>，在Linux上，用的是<strong>int 80</strong>。</p><p>软中断毕竟还是比较慢的，因为执行软中断就需要内存查表，通过IDTR定位到IDT，再取出函数进行执行。</p><p>系统调用是一个频繁触发的动作，如此这般势必对性能有所影响。在进入奔腾时代后，就加上了上面的三个MSR寄存器，分别存储了执行系统调用后，内核系统调用入口函数所需要的段寄存器、堆栈栈顶、函数地址，不再需要内存查表。快速系统调用还提供了专门的CPU指令<strong>sysenter&#x2F;sysexit</strong>用来发起系统调用和退出系统调用。</p><p>在64位上，这一对指令升级为<strong>syscall&#x2F;sysret</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是全部要介绍的寄存器了，需要说明一下的是，这并不是x86CPU全部所有的寄存器，除了这些，还存在XMM、MMX、FPU浮点数运算等其他寄存器。</p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><p>官方文档：<a href="https://shell-storm.org/x86doc/">Intel x86 Opcode Table and Reference (shell-storm.org)</a></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">---------- 一、数据传输指令 ----------------------------------------------------  <br>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.  <br><span class="hljs-number">1</span>. 通用数据传送指令.  <br>    <span class="hljs-keyword">MOV</span>     传送字或字节.  <br>    <span class="hljs-keyword">MOVSX</span>   先符号扩展,再传送.  <br>    <span class="hljs-keyword">MOVZX</span>   先零扩展,再传送.  <br>    <span class="hljs-keyword">PUSH</span>    把字压入堆栈.  <br>    <span class="hljs-keyword">POP</span>     把字弹出堆栈.  <br>    <span class="hljs-keyword">PUSHA</span>   把<span class="hljs-built_in">AX</span>,<span class="hljs-built_in">CX</span>,<span class="hljs-built_in">DX</span>,<span class="hljs-built_in">BX</span>,<span class="hljs-built_in">SP</span>,<span class="hljs-built_in">BP</span>,<span class="hljs-built_in">SI</span>,<span class="hljs-built_in">DI</span>依次压入堆栈.  <br>    <span class="hljs-keyword">POPA</span>    把<span class="hljs-built_in">DI</span>,<span class="hljs-built_in">SI</span>,<span class="hljs-built_in">BP</span>,<span class="hljs-built_in">SP</span>,<span class="hljs-built_in">BX</span>,<span class="hljs-built_in">DX</span>,<span class="hljs-built_in">CX</span>,<span class="hljs-built_in">AX</span>依次弹出堆栈.  <br>    <span class="hljs-keyword">PUSHAD</span>  把<span class="hljs-built_in">EAX</span>,<span class="hljs-built_in">ECX</span>,<span class="hljs-built_in">EDX</span>,<span class="hljs-built_in">EBX</span>,<span class="hljs-built_in">ESP</span>,<span class="hljs-built_in">EBP</span>,<span class="hljs-built_in">ESI</span>,<span class="hljs-built_in">EDI</span>依次压入堆栈.  <br>    <span class="hljs-keyword">POPAD</span>   把<span class="hljs-built_in">EDI</span>,<span class="hljs-built_in">ESI</span>,<span class="hljs-built_in">EBP</span>,<span class="hljs-built_in">ESP</span>,<span class="hljs-built_in">EBX</span>,<span class="hljs-built_in">EDX</span>,<span class="hljs-built_in">ECX</span>,<span class="hljs-built_in">EAX</span>依次弹出堆栈.  <br>    <span class="hljs-keyword">BSWAP</span>   交换<span class="hljs-number">32</span>位寄存器里字节的顺序  <br>    <span class="hljs-keyword">XCHG</span>    交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数)  <br>    <span class="hljs-keyword">CMPXCHG</span> 比较并交换操作数.(第二个操作数必须为累加器<span class="hljs-built_in">AL</span>/<span class="hljs-built_in">AX</span>/<span class="hljs-built_in">EAX</span>)  <br>    <span class="hljs-keyword">XADD</span>    先交换再累加.(结果在第一个操作数里)  <br>    <span class="hljs-keyword">XLAT</span>    字节查表转换.----<span class="hljs-built_in">BX</span>指向一张<span class="hljs-number">256</span>字节的表的起点,<span class="hljs-built_in">AL</span>为表的索引值(<span class="hljs-number">0</span>-<span class="hljs-number">255</span>,即<span class="hljs-number">0</span>-<span class="hljs-number">FFH</span>)<span class="hljs-comment">;返回AL为查表结果.([BX+AL]-&gt;AL)  </span><br><span class="hljs-number">2</span>. 输入输出端口传送指令.  <br>    <span class="hljs-keyword">IN</span>      I/O端口输入. ( 语法: <span class="hljs-keyword">IN</span>   累加器,    &#123;端口号│<span class="hljs-built_in">DX</span>&#125; )  <br>    <span class="hljs-keyword">OUT</span>     I/O端口输出. ( 语法: <span class="hljs-keyword">OUT</span> &#123;端口号│<span class="hljs-built_in">DX</span>&#125;,累加器 )输入输出端口由立即方式指定时,    其范围是 <span class="hljs-number">0</span>-<span class="hljs-number">255</span><span class="hljs-comment">; 由寄存器 DX 指定时,其范围是    0-65535.  </span><br><span class="hljs-number">3</span>. 目的地址传送指令.  <br>    <span class="hljs-keyword">LEA</span>     装入有效地址.例: <span class="hljs-keyword">LEA</span> <span class="hljs-built_in">DX</span>,string <span class="hljs-comment">;把偏移地址存到DX.  </span><br>    <span class="hljs-keyword">LDS</span>     传送目标指针,把指针内容装入<span class="hljs-built_in">DS</span>.例: <span class="hljs-keyword">LDS</span> <span class="hljs-built_in">SI</span>,string   <span class="hljs-comment">;把段地址:偏移地址存到DS:SI.  </span><br>    <span class="hljs-keyword">LES</span>     传送目标指针,把指针内容装入<span class="hljs-built_in">ES</span>.例: <span class="hljs-keyword">LES</span> <span class="hljs-built_in">DI</span>,string   <span class="hljs-comment">;把段地址:偏移地址存到ES:DI.  </span><br>    <span class="hljs-keyword">LFS</span>     传送目标指针,把指针内容装入<span class="hljs-built_in">FS</span>.例: <span class="hljs-keyword">LFS</span> <span class="hljs-built_in">DI</span>,string   <span class="hljs-comment">;把段地址:偏移地址存到FS:DI.  </span><br>    <span class="hljs-keyword">LGS</span>     传送目标指针,把指针内容装入<span class="hljs-built_in">GS</span>.例: <span class="hljs-keyword">LGS</span> <span class="hljs-built_in">DI</span>,string   <span class="hljs-comment">;把段地址:偏移地址存到GS:DI.  </span><br>    <span class="hljs-keyword">LSS</span>     传送目标指针,把指针内容装入<span class="hljs-built_in">SS</span>.例: <span class="hljs-keyword">LSS</span> <span class="hljs-built_in">DI</span>,string   <span class="hljs-comment">;把段地址:偏移地址存到SS:DI.  </span><br><span class="hljs-number">4</span>. 标志传送指令.  <br>    <span class="hljs-keyword">LAHF</span>    标志寄存器传送,把标志装入<span class="hljs-number">AH</span>.  <br>    <span class="hljs-keyword">SAHF</span>    标志寄存器传送,把<span class="hljs-number">AH</span>内容装入标志寄存器.  <br>    <span class="hljs-keyword">PUSHF</span>   标志入栈.  <br>    <span class="hljs-keyword">POPF</span>    标志出栈.  <br>    PUSHD   <span class="hljs-number">32</span>位标志入栈.  <br>    POPD    <span class="hljs-number">32</span>位标志出栈.  <br>---------- 二、算术运算指令 ----------------------------------------------------  <br>    <span class="hljs-keyword">ADD</span>     加法.  <br>    <span class="hljs-keyword">ADC</span>     带进位加法.  <br>    <span class="hljs-keyword">INC</span>     加 <span class="hljs-number">1</span>.  <br>    <span class="hljs-keyword">AAA</span>     加法的ASCII码调整.  <br>    <span class="hljs-keyword">DAA</span>     加法的十进制调整.  <br>    <span class="hljs-keyword">SUB</span>     减法.  <br>    <span class="hljs-keyword">SBB</span>     带借位减法.  <br>    <span class="hljs-keyword">DEC</span>     减 <span class="hljs-number">1</span>.  <br>    <span class="hljs-keyword">NEG</span>     求反(以<span class="hljs-number">0</span> 减之).  <br>    <span class="hljs-keyword">CMP</span>     比较.(两操作数作减法,仅修改标志位,不回送结果，相同为<span class="hljs-number">1</span>).  <br>    <span class="hljs-keyword">AAS</span>     减法的ASCII码调整.  <br>    <span class="hljs-keyword">DAS</span>     减法的十进制调整.  <br>    <span class="hljs-keyword">MUL</span>     无符号乘法.结果回送<span class="hljs-number">AH</span>和<span class="hljs-built_in">AL</span>(字节运算),或<span class="hljs-built_in">DX</span>和<span class="hljs-built_in">AX</span>(字运算),  <br>    <span class="hljs-keyword">IMUL</span>    整数乘法.结果回送<span class="hljs-number">AH</span>和<span class="hljs-built_in">AL</span>(字节运算),或<span class="hljs-built_in">DX</span>和<span class="hljs-built_in">AX</span>(字运算),  <br>    <span class="hljs-keyword">AAM</span>     乘法的ASCII码调整.  <br>    <span class="hljs-keyword">DIV</span>     无符号除法.结果回送:商回送<span class="hljs-built_in">AL</span>,余数回送<span class="hljs-number">AH</span>, (字节运算)<span class="hljs-comment">;或 商回送AX,余数回送DX, (字运算).  </span><br>    <span class="hljs-keyword">IDIV</span>    整数除法.结果回送:商回送<span class="hljs-built_in">AL</span>,余数回送<span class="hljs-number">AH</span>, (字节运算)<span class="hljs-comment">;或 商回送AX,余数回送DX, (字运算).  </span><br>    <span class="hljs-keyword">AAD</span>     除法的ASCII码调整.  <br>    <span class="hljs-keyword">CBW</span>     字节转换为字. (把<span class="hljs-built_in">AL</span>中字节的符号扩展到<span class="hljs-number">AH</span>中去)  <br>    <span class="hljs-keyword">CWD</span>     字转换为双字. (把<span class="hljs-built_in">AX</span>中的字的符号扩展到<span class="hljs-built_in">DX</span>中去)  <br>    <span class="hljs-keyword">CWDE</span>    字转换为双字. (把<span class="hljs-built_in">AX</span>中的字符号扩展到<span class="hljs-built_in">EAX</span>中去)  <br>    <span class="hljs-keyword">CDQ</span>     双字扩展. (把<span class="hljs-built_in">EAX</span>中的字的符号扩展到<span class="hljs-built_in">EDX</span>中去)  <br>---------- 三、逻辑运算指令 ----------------------------------------------------  <br>    <span class="hljs-keyword">AND</span>     与运算.  <br>    <span class="hljs-keyword">OR</span>      或运算.  <br>    <span class="hljs-keyword">XOR</span>     异或运算.  <br>    <span class="hljs-keyword">NOT</span>     取反.  <br>    <span class="hljs-keyword">TEST</span>    测试.(两操作数作与运算,仅修改标志位,不回送结果).  <br>    <span class="hljs-keyword">SHL</span>     逻辑左移.  <br>    <span class="hljs-keyword">SAL</span>     算术左移.(=<span class="hljs-keyword">SHL</span>)  <br>    <span class="hljs-keyword">SHR</span>     逻辑右移.  <br>    <span class="hljs-keyword">SAR</span>     算术右移.(=<span class="hljs-keyword">SHR</span>)  <br>    <span class="hljs-keyword">ROL</span>     循环左移.  <br>    <span class="hljs-keyword">ROR</span>     循环右移.  <br>    <span class="hljs-keyword">RCL</span>     通过进位的循环左移.  <br>    <span class="hljs-keyword">RCR</span>     通过进位的循环右移.  <br>              以上八种移位指令,其移位次数可达<span class="hljs-number">255</span>次.  <br>              移位一次时, 可直接用操作码. 如 <span class="hljs-keyword">SHL</span> <span class="hljs-built_in">AX</span>,<span class="hljs-number">1</span>.  <br>              移位&gt;<span class="hljs-number">1</span>次时, 则由寄存器<span class="hljs-built_in">CL</span>给出移位次数.  <br>              如 <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">04</span>   <span class="hljs-keyword">SHL</span> <span class="hljs-built_in">AX</span>,<span class="hljs-built_in">CL</span>  <br>---------- 四、串指令 ----------------------------------------------------------  <br><span class="hljs-symbol">              DS:</span><span class="hljs-built_in">SI</span> 源串段寄存器 :源串变址.  <br><span class="hljs-symbol">              ES:</span><span class="hljs-built_in">DI</span> 目标串段寄存器:目标串变址.  <br>              <span class="hljs-built_in">CX</span> 重复次数计数器.  <br>              <span class="hljs-built_in">AL</span>/<span class="hljs-built_in">AX</span> 扫描值.  <br>              D标志   <span class="hljs-number">0</span>表示重复操作中<span class="hljs-built_in">SI</span>和<span class="hljs-built_in">DI</span>应自动增量<span class="hljs-comment">; 1表示应自动减量.  </span><br>              Z标志   用来控制扫描或比较操作的结束.  <br>    MOVS    串传送.( <span class="hljs-keyword">MOVSB</span> 传送字符. <span class="hljs-keyword">MOVSW</span> 传送字. <span class="hljs-keyword">MOVSD</span> 传送双字. )  <br>    CMPS    串比较.( <span class="hljs-keyword">CMPSB</span> 比较字符. <span class="hljs-keyword">CMPSW</span> 比较字. )  <br>    SCAS    串扫描.把<span class="hljs-built_in">AL</span>或<span class="hljs-built_in">AX</span>的内容与目标串作比较,比较结果反映在标志位.  <br>    LODS    装入串.把源串中的元素(字或字节)逐一装入<span class="hljs-built_in">AL</span>或<span class="hljs-built_in">AX</span>中.( <span class="hljs-keyword">LODSB</span> 传送字符. <span class="hljs-keyword">LODSW</span> 传送字.    <span class="hljs-keyword">LODSD</span> 传送双字. )  <br>    STOS    保存串.是LODS的逆过程.  <br>    <span class="hljs-keyword">REP</span>         当<span class="hljs-built_in">CX</span>/<span class="hljs-built_in">ECX</span>&lt;&gt;<span class="hljs-number">0</span>时重复.  <br>    <span class="hljs-keyword">REPE</span>/<span class="hljs-keyword">REPZ</span>   当ZF=<span class="hljs-number">1</span>或比较结果相等,且<span class="hljs-built_in">CX</span>/<span class="hljs-built_in">ECX</span>&lt;&gt;<span class="hljs-number">0</span>时重复.  <br>    <span class="hljs-keyword">REPNE</span>/<span class="hljs-keyword">REPNZ</span> 当ZF=<span class="hljs-number">0</span>或比较结果不相等,且<span class="hljs-built_in">CX</span>/<span class="hljs-built_in">ECX</span>&lt;&gt;<span class="hljs-number">0</span>时重复.  <br>    REPC        当CF=<span class="hljs-number">1</span>且<span class="hljs-built_in">CX</span>/<span class="hljs-built_in">ECX</span>&lt;&gt;<span class="hljs-number">0</span>时重复.  <br>    REPNC       当CF=<span class="hljs-number">0</span>且<span class="hljs-built_in">CX</span>/<span class="hljs-built_in">ECX</span>&lt;&gt;<span class="hljs-number">0</span>时重复.  <br>---------- 五、程序转移指令 ----------------------------------------------------  <br><span class="hljs-number">1</span>. 无条件转移指令 (长转移)  <br>    <span class="hljs-keyword">JMP</span>         无条件转移指令  <br>    <span class="hljs-keyword">CALL</span>        过程调用  <br>    <span class="hljs-keyword">RET</span>/<span class="hljs-keyword">RETF</span>    过程返回.  <br><span class="hljs-number">2</span>. 条件转移指令   (短转移,-<span class="hljs-number">128</span>到+<span class="hljs-number">127</span>的距离内)( 当且仅当(SF <span class="hljs-keyword">XOR</span> OF)=<span class="hljs-number">1</span>时,OP1&lt;OP2 )  <br>    <span class="hljs-keyword">JA</span>/<span class="hljs-keyword">JNBE</span>     不小于或不等于时转移.  <br>    <span class="hljs-keyword">JAE</span>/<span class="hljs-keyword">JNB</span>     大于或等于转移.  <br>    <span class="hljs-keyword">JB</span>/<span class="hljs-keyword">JNAE</span>     小于转移.  <br>    <span class="hljs-keyword">JBE</span>/<span class="hljs-keyword">JNA</span>     小于或等于转移.  <br>        以上四条,测试无符号整数运算的结果(标志C和Z).  <br>    <span class="hljs-keyword">JG</span>/<span class="hljs-keyword">JNLE</span>     大于转移.  <br>    <span class="hljs-keyword">JGE</span>/<span class="hljs-keyword">JNL</span>     大于或等于转移.  <br>    <span class="hljs-keyword">JL</span>/<span class="hljs-keyword">JNGE</span>     小于转移.  <br>    <span class="hljs-keyword">JLE</span>/<span class="hljs-keyword">JNG</span>     小于或等于转移.  <br>        以上四条,测试带符号整数运算的结果(标志S,O和Z).  <br>    <span class="hljs-keyword">JE</span>/<span class="hljs-keyword">JZ</span>       等于转移.  <br>    <span class="hljs-keyword">JNE</span>/<span class="hljs-keyword">JNZ</span>     不等于时转移.  <br>    <span class="hljs-keyword">JC</span>          有进位时转移.  <br>    <span class="hljs-keyword">JNC</span>         无进位时转移.  <br>    <span class="hljs-keyword">JNO</span>         不溢出时转移.  <br>    <span class="hljs-keyword">JNP</span>/<span class="hljs-keyword">JPO</span>     奇偶性为奇数时转移.  <br>    <span class="hljs-keyword">JNS</span>         符号位为 <span class="hljs-string">&quot;0&quot;</span> 时转移.  <br>    <span class="hljs-keyword">JO</span>          溢出转移.  <br>    <span class="hljs-keyword">JP</span>/<span class="hljs-keyword">JPE</span>      奇偶性为偶数时转移.  <br>    <span class="hljs-keyword">JS</span>          符号位为 <span class="hljs-string">&quot;1&quot;</span> 时转移.  <br><span class="hljs-number">3</span>. 循环控制指令(短转移)  <br>    <span class="hljs-keyword">LOOP</span>            <span class="hljs-built_in">CX</span>不为零时循环.  <br>    <span class="hljs-keyword">LOOPE</span>/<span class="hljs-keyword">LOOPZ</span>     <span class="hljs-built_in">CX</span>不为零且标志Z=<span class="hljs-number">1</span>时循环.  <br>    <span class="hljs-keyword">LOOPNE</span>/<span class="hljs-keyword">LOOPNZ</span>   <span class="hljs-built_in">CX</span>不为零且标志Z=<span class="hljs-number">0</span>时循环.  <br>    <span class="hljs-keyword">JCXZ</span>            <span class="hljs-built_in">CX</span>为零时转移.  <br>    <span class="hljs-keyword">JECXZ</span>           <span class="hljs-built_in">ECX</span>为零时转移.  <br><span class="hljs-number">4</span>. 中断指令  <br>    <span class="hljs-keyword">INT</span>         中断指令  <br>    <span class="hljs-keyword">INTO</span>        溢出中断  <br>    <span class="hljs-keyword">IRET</span>        中断返回  <br><span class="hljs-number">5</span>. 处理器控制指令  <br>    <span class="hljs-keyword">HLT</span>         处理器暂停,  直到出现中断或复位信号才继续.  <br>    WAIT        当芯片引线<span class="hljs-keyword">TEST</span>为高电平时使<span class="hljs-meta">CPU</span>进入等待状态.  <br>    ESC         转换到外处理器.  <br>    <span class="hljs-keyword">LOCK</span>        封锁总线.  <br>    <span class="hljs-keyword">NOP</span>         空操作.  <br>    <span class="hljs-keyword">STC</span>         置进位标志位.  <br>    <span class="hljs-keyword">CLC</span>         清进位标志位.  <br>    <span class="hljs-keyword">CMC</span>         进位标志取反.  <br>    <span class="hljs-keyword">STD</span>         置方向标志位.  <br>    <span class="hljs-keyword">CLD</span>         清方向标志位.  <br>    <span class="hljs-keyword">STI</span>         置中断允许位.  <br>    <span class="hljs-keyword">CLI</span>         清中断允许位.  <br>---------- 六、伪指令 ----------------------------------------------------------  <br>    <span class="hljs-built_in">DW</span>          定义字(<span class="hljs-number">2</span>字节).  <br>    PROC        定义过程.  <br>    ENDP        过程结束.  <br>    <span class="hljs-meta">SEGMENT</span>     定义段.  <br>    <span class="hljs-meta">ASSUME</span>      建立段寄存器寻址.  <br>    ENDS        段结束.  <br>    END         程序结束.  <br>---------- 七、处理机控制指令：标志处理指令 ------------------------------------  <br>    <span class="hljs-keyword">CLC</span>     进位位置<span class="hljs-number">0</span>指令  <br>    <span class="hljs-keyword">CMC</span>     进位位求反指令  <br>    <span class="hljs-keyword">STC</span>     进位位置为<span class="hljs-number">1</span>指令  <br>    <span class="hljs-keyword">CLD</span>     方向标志置<span class="hljs-number">1</span>指令  <br>    <span class="hljs-keyword">STD</span>     方向标志位置<span class="hljs-number">1</span>指令  <br>    <span class="hljs-keyword">CLI</span>     中断标志置<span class="hljs-number">0</span>指令  <br>    <span class="hljs-keyword">STI</span>     中断标志置<span class="hljs-number">1</span>指令  <br>    <span class="hljs-keyword">NOP</span>     无操作  <br>    <span class="hljs-keyword">HLT</span>     停机  <br>    WAIT    等待  <br>    ESC     换码  <br>    <span class="hljs-keyword">LOCK</span>    封锁  <br>========== 浮点运算指令集 ======================================================  <br>---------- 一、控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)----  <br><span class="hljs-keyword">FINIT</span>                 初始化浮点部件                  机器码  9B <span class="hljs-built_in">DB</span> E3  <br><span class="hljs-keyword">FCLEX</span>                 清除异常                         机器码  9B <span class="hljs-built_in">DB</span> E2  <br><span class="hljs-keyword">FDISI</span>                 浮点检查禁止中断                 机器码  9B <span class="hljs-built_in">DB</span> E1  <br><span class="hljs-keyword">FENI</span>                  浮点检查禁止中断二            机器码  9B <span class="hljs-built_in">DB</span> E0  <br>WAIT                  同步<span class="hljs-meta">CPU</span>和FPU                    机器码  9B  <br><span class="hljs-keyword">FWAIT</span>                 同步<span class="hljs-meta">CPU</span>和FPU                    机器码  D9 D0  <br><span class="hljs-keyword">FNOP</span>                  无操作                          机器码  DA E9  <br><span class="hljs-keyword">FXCH</span>                  交换<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)和<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)                机器码  D9 C9  <br><span class="hljs-keyword">FXCH</span> <span class="hljs-built_in">ST</span>(i)            交换<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)和<span class="hljs-built_in">ST</span>(i)                机器码  D9 C1iii  <br><span class="hljs-keyword">FSTSW</span> <span class="hljs-built_in">ax</span>              状态字到<span class="hljs-built_in">ax</span>                       机器码  9B DF E0  <br><span class="hljs-keyword">FSTSW</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  状态字到mem                      机器码  9B <span class="hljs-built_in">DD</span> mm111mmm  <br><span class="hljs-keyword">FLDCW</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  mem到状态字                      机器码  D9 mm101mmm  <br><span class="hljs-keyword">FSTCW</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  控制字到mem                      机器码  9B D9 mm111mmm  <br>  <br><span class="hljs-keyword">FLDENV</span>  <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  mem到全环境                      机器码  D9 mm100mmm  <br><span class="hljs-keyword">FSTENV</span>  <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  全环境到mem                      机器码  9B D9 mm110mmm  <br><span class="hljs-keyword">FRSTOR</span>  <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  mem到FPU状态                    机器码  <span class="hljs-built_in">DD</span> mm100mmm  <br><span class="hljs-keyword">FSAVE</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  FPU状态到mem                    机器码  9B <span class="hljs-built_in">DD</span> mm110mmm  <br>  <br><span class="hljs-keyword">FFREE</span> <span class="hljs-built_in">ST</span>(i)           标志<span class="hljs-built_in">ST</span>(i)未使用                   机器码  <span class="hljs-built_in">DD</span> C0iii  <br><span class="hljs-keyword">FDECSTP</span>               减少栈指针<span class="hljs-number">1</span>-&gt;<span class="hljs-number">0</span> <span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>             机器码  D9 F6  <br><span class="hljs-keyword">FINCSTP</span>               增加栈指针<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span> <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>             机器码  D9 F7  <br><span class="hljs-keyword">FSETPM</span>                浮点设置保护                       机器码  <span class="hljs-built_in">DB</span> E4  <br>---------- 二、数据传送指令 ----------------------------------------------------  <br><span class="hljs-keyword">FLDZ</span>                  将<span class="hljs-number">0.0</span>装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)                  机器码  D9 EE  <br><span class="hljs-keyword">FLD1</span>                  将<span class="hljs-number">1.0</span>装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)                  机器码  D9 E8  <br><span class="hljs-keyword">FLDPI</span>                 将π装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)                    机器码  D9 EB  <br><span class="hljs-keyword">FLDL2T</span>                将ln10/ln2装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)             机器码  D9 E9  <br><span class="hljs-keyword">FLDL2E</span>                将<span class="hljs-number">1</span>/ln2装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)                机器码  D9 EA  <br><span class="hljs-keyword">FLDLG2</span>                将ln2/ln10装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)             机器码  D9 EC  <br><span class="hljs-keyword">FLDLN2</span>                将ln2装入<span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)                  机器码  D9 ED  <br>  <br><span class="hljs-keyword">FLD</span>    real4 <span class="hljs-built_in">ptr</span> mem  装入mem的单精度浮点数             机器码  D9 mm000mmm  <br><span class="hljs-keyword">FLD</span>    real8 <span class="hljs-built_in">ptr</span> mem  装入mem的双精度浮点数             机器码  <span class="hljs-built_in">DD</span> mm000mmm  <br><span class="hljs-keyword">FLD</span>   real10 <span class="hljs-built_in">ptr</span> mem  装入mem的十字节浮点数             机器码  <span class="hljs-built_in">DB</span> mm101mmm  <br>  <br><span class="hljs-keyword">FILD</span>    <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  装入mem的二字节整数              机器码  DF mm000mmm  <br><span class="hljs-keyword">FILD</span>   <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> mem  装入mem的四字节整数              机器码  <span class="hljs-built_in">DB</span> mm000mmm  <br><span class="hljs-keyword">FILD</span>   <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> mem  装入mem的八字节整数              机器码  DF mm101mmm  <br>  <br><span class="hljs-keyword">FBLD</span>   tbyte <span class="hljs-built_in">ptr</span> mem  装入mem的十字节BCD数            机器码  DF mm100mmm  <br>  <br><span class="hljs-keyword">FST</span>    real4 <span class="hljs-built_in">ptr</span> mem  保存单精度浮点数到mem             机器码  D9 mm010mmm  <br><span class="hljs-keyword">FST</span>    real8 <span class="hljs-built_in">ptr</span> mem  保存双精度浮点数到mem             机器码  <span class="hljs-built_in">DD</span> mm010mmm  <br>  <br><span class="hljs-keyword">FIST</span>    <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  保存二字节整数到mem              机器码  DF mm010mmm  <br><span class="hljs-keyword">FIST</span>   <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> mem  保存四字节整数到mem              机器码  <span class="hljs-built_in">DB</span> mm010mmm  <br>  <br><span class="hljs-keyword">FSTP</span>   real4 <span class="hljs-built_in">ptr</span> mem  保存单精度浮点数到mem并出栈      机器码  D9 mm011mmm  <br><span class="hljs-keyword">FSTP</span>   real8 <span class="hljs-built_in">ptr</span> mem  保存双精度浮点数到mem并出栈      机器码  <span class="hljs-built_in">DD</span> mm011mmm  <br><span class="hljs-keyword">FSTP</span>  real10 <span class="hljs-built_in">ptr</span> mem  保存十字节浮点数到mem并出栈      机器码  <span class="hljs-built_in">DB</span> mm111mmm  <br>  <br><span class="hljs-keyword">FISTP</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  保存二字节整数到mem并出栈           机器码  DF mm011mmm  <br><span class="hljs-keyword">FISTP</span>  <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> mem  保存四字节整数到mem并出栈           机器码  <span class="hljs-built_in">DB</span> mm011mmm  <br><span class="hljs-keyword">FISTP</span>  <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> mem  保存八字节整数到mem并出栈           机器码  DF mm111mmm  <br>  <br><span class="hljs-keyword">FBSTP</span>  tbyte <span class="hljs-built_in">ptr</span> mem  保存十字节BCD数到mem并出栈     机器码  DF mm110mmm  <br>  <br><span class="hljs-keyword">FCMOVB</span>                <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) &lt;时传送              机器码  DA C0iii  <br><span class="hljs-keyword">FCMOVBE</span>               <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) &lt;=时传送             机器码  DA D0iii  <br><span class="hljs-keyword">FCMOVE</span>                <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) =时传送             机器码  DA C1iii  <br><span class="hljs-keyword">FCMOVNB</span>               <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) &gt;=时传送             机器码  <span class="hljs-built_in">DB</span> C0iii  <br><span class="hljs-keyword">FCMOVNBE</span>              <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) &gt;时传送              机器码  <span class="hljs-built_in">DB</span> D0iii  <br><span class="hljs-keyword">FCMOVNE</span>               <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) !=时传送            机器码  <span class="hljs-built_in">DB</span> C1iii  <br><span class="hljs-keyword">FCMOVNU</span>               <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) 有序时传送        机器码  <span class="hljs-built_in">DB</span> D1iii  <br><span class="hljs-keyword">FCMOVU</span>                <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i) 无序时传送        机器码  DA D1iii  <br>---------- 三、比较指令   --------------------------------------------------------  <br><span class="hljs-keyword">FCOM</span>                  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)                      机器码  D8 D1  <br><span class="hljs-keyword">FCOMI</span>                 <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i)  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)         机器码  <span class="hljs-built_in">DB</span> F0iii  <br><span class="hljs-keyword">FCOMIP</span>                <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">ST</span>(i)  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)并出栈   机器码  DF F0iii  <br><span class="hljs-keyword">FCOM</span>   real4 <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-实数mem                      机器码  D8 mm010mmm  <br><span class="hljs-keyword">FCOM</span>   real8 <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-实数mem                      机器码  DC mm010mmm  <br>  <br><span class="hljs-keyword">FICOM</span>   <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-整数mem                      机器码  DE mm010mmm  <br><span class="hljs-keyword">FICOM</span>  <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-整数mem                      机器码  DA mm010mmm  <br><span class="hljs-keyword">FICOMP</span>  <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-整数mem并出栈               机器码  DE mm011mmm  <br><span class="hljs-keyword">FICOMP</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> mem  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-整数mem并出栈               机器码  DA mm011mmm  <br>  <br><span class="hljs-keyword">FTST</span>                  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-number">0</span>                          机器码  D9 E4  <br><span class="hljs-keyword">FUCOM</span>  <span class="hljs-built_in">ST</span>(i)          <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(i)                      机器码  <span class="hljs-built_in">DD</span> E0iii  <br><span class="hljs-keyword">FUCOMP</span> <span class="hljs-built_in">ST</span>(i)          <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(i)并出栈                   机器码  <span class="hljs-built_in">DD</span> E1iii  <br><span class="hljs-keyword">FUCOMPP</span>               <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)-<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)并二次出栈             机器码  DA E9  <br><span class="hljs-keyword">FXAM</span>                  <span class="hljs-built_in">ST</span>(<span class="hljs-number">0</span>)规格类型                    机器码  D9 E5  <br>---------- 四、运算指令   --------------------------------------------------------  <br><span class="hljs-keyword">FADD</span>                  把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器)  相加，并将结果存入目的操作数  <br><span class="hljs-keyword">FADDP</span>  <span class="hljs-built_in">ST</span>(i),<span class="hljs-built_in">ST</span>       这个指令是使目的操作数加上 <span class="hljs-built_in">ST</span>  缓存器，并弹出 <span class="hljs-built_in">ST</span> 缓存器，而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了  <br><span class="hljs-keyword">FIADD</span>                 <span class="hljs-keyword">FIADD</span> 是把 <span class="hljs-built_in">ST</span>   加上来源操作数，然后再存入 <span class="hljs-built_in">ST</span> 缓存器，来源操作数必须是字组整数或短整数形态的变数  <br>  <br><span class="hljs-keyword">FSUB</span>                  减  <br><span class="hljs-keyword">FSUBP</span>  <br><span class="hljs-keyword">FSUBR</span>                 减数与被减数互换  <br><span class="hljs-keyword">FSUBRP</span>  <br><span class="hljs-keyword">FISUB</span>  <br><span class="hljs-keyword">FISUBR</span>  <br>  <br><span class="hljs-keyword">FMUL</span>                  乘  <br><span class="hljs-keyword">FMULP</span>  <br><span class="hljs-keyword">FIMUL</span>  <br>  <br><span class="hljs-keyword">FDIV</span>                  除  <br><span class="hljs-keyword">FDIVP</span>  <br><span class="hljs-keyword">FDIVR</span>  <br><span class="hljs-keyword">FDIVRP</span>  <br><span class="hljs-keyword">FIDIV</span>  <br><span class="hljs-keyword">FIDIVR</span>  <br>  <br><span class="hljs-keyword">FCHS</span>                  改变 <span class="hljs-built_in">ST</span> 的正负值  <br>  <br><span class="hljs-keyword">FABS</span>                  把 <span class="hljs-built_in">ST</span>  之值取出，取其绝对值后再存回去。  <br>  <br><span class="hljs-keyword">FSQRT</span>                 将 <span class="hljs-built_in">ST</span>  之值取出，开根号后再存回去。  <br>  <br><span class="hljs-keyword">FSCALE</span>                这个指令是计算 <span class="hljs-built_in">ST</span>*<span class="hljs-number">2</span>^<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)之值，再把结果存入 <span class="hljs-built_in">ST</span> 里而 <span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)   之值不变。<span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)  必须是在 -<span class="hljs-number">32768</span> 到 <span class="hljs-number">32768</span> (-<span class="hljs-number">215</span> 到 <span class="hljs-number">215</span> )之间的整数，如果超过这个范围计算结果无法确定，如果不是整数 <span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>)    会先向零舍入成整数再计算。所以为安全起见，最好是由字组整数载入到 <span class="hljs-built_in">ST</span>(<span class="hljs-number">1</span>) 里。  <br>  <br><span class="hljs-keyword">FRNDINT</span>               这个指令是把 <span class="hljs-built_in">ST</span> 的数值舍入成整数，FPU    提供四种舍入方式，由 FPU 的控制字组(control    <span class="hljs-built_in">word</span>)中的 RC 两个位决定  <br>                          RC    舍入控制  <br>                          <span class="hljs-number">00</span>    四舍五入  <br>                          <span class="hljs-number">01</span>    向负无限大舍入  <br>                          <span class="hljs-number">10</span>    向正无限大舍入  <br>                          <span class="hljs-number">11</span>    向零舍去  <br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、汇编语言是什么？&quot;&gt;&lt;a href=&quot;#一、汇编语言是什么？&quot; class=&quot;headerlink&quot; title=&quot;一、汇编语言是什么？&quot;&gt;&lt;/a&gt;一、汇编语言是什么？&lt;/h2&gt;&lt;p&gt;我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一些东西</title>
    <link href="http://example.com/2022/10/01/%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/"/>
    <id>http://example.com/2022/10/01/%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/</id>
    <published>2022-09-30T16:00:00.000Z</published>
    <updated>2023-08-04T07:13:38.203Z</updated>
    
    <content type="html"><![CDATA[<hr><p>指令执行周期</p><p>取指令，译码，执行</p><p>加载执行程序</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.磁盘寻找文件 <span class="hljs-number">2</span>.访问文件信息 <span class="hljs-number">3</span>.加载程序之内存 <span class="hljs-number">4</span>.执行指令，分配Process ID <span class="hljs-number">5</span>.进程自动运行 <span class="hljs-number">6</span>.进程结束后从内存中移除<br></code></pre></td></tr></table></figure><p>32位x86处理器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">操作模式：保护模式，虚拟8086模式（保护模式子模式），实地址模式，系统管理模式<br><br>xmm寄存器<br></code></pre></td></tr></table></figure><p>64位x86处理器</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs llvm">向后兼容<span class="hljs-keyword">x</span><span class="hljs-number">86</span>指令集<br><br>地址长度<span class="hljs-number">64</span>位，虚拟地址控件位<span class="hljs-number">2</span>的<span class="hljs-number">64</span>次方字节<span class="hljs-number">2</span><br><br>可以使用<span class="hljs-number">64</span>位通用寄存器，运行指令具有<span class="hljs-number">64</span>位整数操作数<br><br>比<span class="hljs-keyword">x</span><span class="hljs-number">86</span>多了<span class="hljs-number">8</span>各通用寄存器<br><br>物理地址为<span class="hljs-number">48</span>位，支持<span class="hljs-number">256</span>TB的RAM<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">操作模式：兼容模式，64位模式    <br></code></pre></td></tr></table></figure><p>I&#x2F;O访问层次</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">高级语言函数<br>操作系统（<span class="hljs-built_in">os</span>）<br>BIOS<br>硬件<br></code></pre></td></tr></table></figure><p>汇编语言基本元素</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">整数常量 <span class="hljs-number">0A3h</span>（<span class="hljs-number">16</span>进制<span class="hljs-number">0</span> h） <span class="hljs-number">19d</span>（<span class="hljs-number">10</span>进制，可以不写）<span class="hljs-number">23q</span>/o（八进制） <span class="hljs-number">10011b</span>（二进制）<br>实数常量 <span class="hljs-number">2</span> <span class="hljs-number">3.0</span> +<span class="hljs-number">3.0</span> -<span class="hljs-number">44.2E+5</span> <span class="hljs-number">26.E5</span><br>字符常量 ‘A’ <span class="hljs-string">&quot;A&quot;</span><br>字符串常量   “HELLO”<br>保留字 <span class="hljs-keyword">mov</span> <span class="hljs-keyword">lea</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">sub</span> jcc 寄存器 属性 <span class="hljs-built_in">db</span> <span class="hljs-built_in">dword</span> 运算符<br>标识符 第一个字符是有限制的，标识符不能与保留字相同<br>伪指令 data offset<br>指令 <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>，<span class="hljs-number">123</span><br>注释 ；<br></code></pre></td></tr></table></figure><p>定义数据类型  </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">整数：<br><span class="hljs-built_in">BYTE</span> <span class="hljs-number">8</span>位（无符号） SBYTE（有符号，汇编） <br><span class="hljs-built_in">WORD</span> <span class="hljs-number">16</span>位（无符号） SWORD（有符号）<br><span class="hljs-built_in">DWORD</span> <span class="hljs-number">32</span>位（无符号）SDWORD（有符号）<br>FWORD <span class="hljs-number">48</span>位（无符号）保护模式的远指针  SFWORD（有符号）<br><span class="hljs-built_in">QWORD</span> <span class="hljs-number">64</span>位 整数<br>TBYTE <span class="hljs-number">80</span>位 整数<br>实数：<br>REAL4 <span class="hljs-number">32</span>位 短实数<br>REAL8 <span class="hljs-number">64</span>位 长实数<br>REAL10 <span class="hljs-number">80</span>位 拓展实数<br>伪指令：<br><span class="hljs-built_in">db</span> <span class="hljs-number">8</span>位整数 char ASCII<br><span class="hljs-built_in">dw</span> <span class="hljs-number">16</span>位整数<br><span class="hljs-built_in">dd</span> <span class="hljs-number">32</span>为整数或者实数<br><span class="hljs-built_in">dq</span> <span class="hljs-number">64</span>位整数或者实数<br><span class="hljs-built_in">dt</span> <span class="hljs-number">80</span>位的整数<br>大端序与小端序：<br>大：<span class="hljs-number">12345678</span><br>小：<span class="hljs-number">78563412</span><br></code></pre></td></tr></table></figure><p>数据传送指令：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">mov</span> reg32，imm32<br>操作数类型<br>立即数；寄存器操作数 <span class="hljs-built_in">eax</span> <span class="hljs-built_in">ebx</span>；内存操作数<br><br>reg 通用寄存器 <br>sreg 段寄存器<br>imm 立即数<br>mem 内存<br><br><span class="hljs-keyword">mov</span> 目的操作数，源操作数（两个位数相同，不能同时为内存操作数）<br><span class="hljs-keyword">mov</span> reg，reg<br><span class="hljs-keyword">mov</span> mem，reg<br><span class="hljs-keyword">mov</span> reg，mem<br><span class="hljs-keyword">mov</span> mem，imm<br><span class="hljs-keyword">mov</span> reg，imm<br><span class="hljs-keyword">mov</span> mem，mem 得写成 <span class="hljs-keyword">mov</span> reg，mem       <span class="hljs-keyword">mov</span> mem reg<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">cx</span> 得写成 <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>，FFFFFFFF <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>，<span class="hljs-built_in">cx</span><br><span class="hljs-built_in">eax</span> = <span class="hljs-number">101010101010101010</span><br><span class="hljs-built_in">cx</span> = <span class="hljs-number">10101010</span><br><span class="hljs-number">00000000110101010</span><br><br><span class="hljs-keyword">movzx</span><br><span class="hljs-keyword">movzx</span> <span class="hljs-built_in">eax</span>，<span class="hljs-built_in">cx</span> 可以（全<span class="hljs-number">0</span>拓展）<br><span class="hljs-built_in">eax</span> = <span class="hljs-number">101010101010101010</span><br><span class="hljs-built_in">cx</span> = <span class="hljs-number">10101010</span><br><span class="hljs-number">0000000010101010</span><br><br><span class="hljs-keyword">movsx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>，<span class="hljs-built_in">cx</span><br><span class="hljs-built_in">eax</span> = <span class="hljs-number">101010101010101010</span><br><span class="hljs-built_in">cx</span> = <span class="hljs-number">10101010</span><br><span class="hljs-number">111111111110101010</span><br><br><span class="hljs-keyword">LAHF</span> //加载标志位到<span class="hljs-number">AH</span>（<span class="hljs-built_in">ax</span>的高八位）中<br><span class="hljs-keyword">lahf</span><br><span class="hljs-keyword">mov</span> flag（<span class="hljs-number">8</span>位整数），<span class="hljs-number">ah</span><br><br><span class="hljs-keyword">sahf</span>  //拷贝回标志位寄存器<br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>，flag<br><span class="hljs-keyword">sahf</span><br><br><span class="hljs-keyword">xchg</span> //交换指令<br><span class="hljs-keyword">xchg</span> reg，reg<br><span class="hljs-keyword">xchg</span> reg，mem<br><span class="hljs-keyword">xchg</span> mem，reg<br></code></pre></td></tr></table></figure><p>加法与减法</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">add</span><br><span class="hljs-keyword">add</span> 操作数<span class="hljs-number">1</span> 操作数<span class="hljs-number">2</span> （操作数类型和<span class="hljs-keyword">mov</span>相同）<br><br><span class="hljs-keyword">sub</span><br><span class="hljs-keyword">sub</span> 操作数<span class="hljs-number">1</span> 操作数<span class="hljs-number">2</span>（操作数类型和<span class="hljs-keyword">mov</span>相同）<br><br><span class="hljs-keyword">inc</span>（自增） <span class="hljs-keyword">dec</span>（自减）<br><br><span class="hljs-keyword">neg</span> 取反符号位也取<br></code></pre></td></tr></table></figure><p>数据相关的运算符和伪指令</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.data</span><br>szStr <span class="hljs-built_in">db</span> “hello <span class="hljs-built_in">word</span>”,<span class="hljs-number">0</span><br>num <span class="hljs-built_in">dword</span> <span class="hljs-number">5</span><br>arrNum <span class="hljs-built_in">dword</span> <span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span><br>var1 <span class="hljs-built_in">db</span> ？<br><br>offset 获取距离段起始位置的偏移<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> offset var1<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> offset arrNum + <span class="hljs-number">4</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>，【<span class="hljs-built_in">eax</span>】 //【】是取地址里面的内容，间接寻址<br><br><span class="hljs-built_in">ptr</span> 用来指定操作数的类型或尺寸<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>，<span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> num //取低十六位<br><br>type 返回当前元素大小<br><br>lengthof 返回数组中元素个数<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>，offset lengthof arrNum<br><br>sizeof 返回数组占的空间<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>，sizeof arrNum<br></code></pre></td></tr></table></figure><p>间接寻址</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">pbyte typedef <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">byte</span> //typedef<br><span class="hljs-meta">.data</span><br>asd pbyte　<span class="hljs-number">1</span><br>var <span class="hljs-built_in">byte</span> <span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">6</span>，<span class="hljs-number">7</span>，<span class="hljs-number">8</span><br><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span> //清零<br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, offset var<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, [<span class="hljs-built_in">eax</span>]<br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span> //<span class="hljs-built_in">byte</span> 是一个字节，加<span class="hljs-number">1</span>到数组下一个元素<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, [<span class="hljs-built_in">eax</span>]<br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span><br>... //完成遍历<br><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span> //清零<br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, offset var<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, [<span class="hljs-built_in">eax</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, [<span class="hljs-built_in">eax</span> + <span class="hljs-number">1</span>] //<span class="hljs-built_in">word</span> +<span class="hljs-number">2</span>, <span class="hljs-built_in">dword</span> + <span class="hljs-number">4</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, [<span class="hljs-built_in">eax</span> + <span class="hljs-number">2</span>]<br>...<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,var[<span class="hljs-built_in">esi</span> * <span class="hljs-number">1</span>] //<span class="hljs-number">1</span>是数据宽度，结果取得是<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>JMP和LOOP</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">jmp</span> //无条件跳转<br><br><span class="hljs-built_in">ecx</span>是<span class="hljs-keyword">loop</span>的计数器<br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>，<span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>，<span class="hljs-number">10</span><br>lp：<br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">loop</span> lp<br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>source <span class="hljs-built_in">byte</span> <span class="hljs-string">&quot;hello world&quot;</span>,<span class="hljs-number">0</span><br>target <span class="hljs-built_in">byte</span> sizeof source dup(<span class="hljs-number">0</span>)<br><br>main proc //执行拷贝<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,sizeof source<br><span class="hljs-symbol">lp:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,source[<span class="hljs-built_in">esi</span> * <span class="hljs-number">1</span>]<br><span class="hljs-keyword">mov</span> target[<span class="hljs-built_in">esi</span> * <span class="hljs-number">1</span>],<span class="hljs-built_in">al</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br><span class="hljs-keyword">loop</span> lp<br><span class="hljs-keyword">push</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">call</span> ExitProcess<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>，<span class="hljs-number">4</span> //堆栈平衡<br><br></code></pre></td></tr></table></figure><p>堆栈操作</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">栈：先进后出<br><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">esp</span> - <span class="hljs-number">4</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">esp</span>　+ <span class="hljs-number">4</span><br><br><span class="hljs-keyword">pushfd</span> <span class="hljs-keyword">popfd</span> 把<span class="hljs-number">32</span>位标志位寄存器压入栈中<br><br><span class="hljs-keyword">pushad</span> <span class="hljs-keyword">popad</span> 通用寄存器压栈<br>按<span class="hljs-built_in">eax</span> <span class="hljs-built_in">ecx</span> <span class="hljs-built_in">edx</span> <span class="hljs-built_in">esp</span> <span class="hljs-built_in">ebp</span> <span class="hljs-built_in">esi</span> <span class="hljs-built_in">edi</span>顺序压栈<br><br><span class="hljs-keyword">pusha</span> <span class="hljs-keyword">popa</span> <span class="hljs-number">16</span>位<br><br>字符串逆序<br><span class="hljs-meta">.data</span> <br>source <span class="hljs-built_in">byte</span> <span class="hljs-string">&quot;hello world&quot;</span>,<span class="hljs-number">0</span><br>sourcesize = ($ - source) - <span class="hljs-number">1</span><br><span class="hljs-meta">.code</span><br>main proc<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,sourcesize<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">lp1:</span><br><span class="hljs-keyword">movzx</span> <span class="hljs-built_in">eax</span>,source[<span class="hljs-built_in">esi</span> * <span class="hljs-number">1</span>] //数据传送指令<span class="hljs-keyword">MOV</span>的变体。无符号扩展，并传送。<br><span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br><span class="hljs-keyword">loop</span> lp1<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,sourcesize<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">lp2:</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span> source[<span class="hljs-built_in">esi</span>],<span class="hljs-built_in">al</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br><span class="hljs-keyword">loop</span> lp2<br><span class="hljs-keyword">push</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">call</span> ExitProcess<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">4</span><br>main ENDP<br>END main<br></code></pre></td></tr></table></figure><p>定义函数</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">call</span> <br><span class="hljs-number">1.</span><span class="hljs-built_in">eip</span>压栈   <span class="hljs-number">2.</span><span class="hljs-keyword">jmp</span>到函数处<br><br><span class="hljs-keyword">ret</span><br><span class="hljs-number">1.</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span> <span class="hljs-number">2.</span>jum <span class="hljs-built_in">eip</span><br><br>addx proc uses <span class="hljs-built_in">esi</span> <span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esi</span>,<span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">esi</span><br><span class="hljs-keyword">ret</span><br>addx ENDP<br><br>mian proc<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>,<span class="hljs-number">5</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-number">6</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">esi</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">call</span> addx<br>main endp<br>end main<br></code></pre></td></tr></table></figure><p>布尔与比较指令</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">test  </span>//测试某位是不是1 运算逻辑就是and 不修改eax的值，改标志位寄存器<br>eflags <br><span class="hljs-keyword">test </span>eax 00000001<br><br>cmp //原理是相减 不修改操作数，修改标志位<br>cmp o1，o2<br>o1 &gt; o2 // zf = 0， cf = 1//无符号数 sf != of<br>o1 &lt; o2 //zf = 0， cf = 0//sf = of<br>o1 = 02 //zf = 1 ，cf = 0//zf = 1<br>zf 零标志位； cf 进位标志位； sf 符号标志位； of 溢出标志位<br><br></code></pre></td></tr></table></figure><p>条件跳转指令</p><table><thead><tr><th align="center">JCC指令</th><th align="center">解释</th><th align="center">英文原文</th><th align="center">检查符号位</th><th align="center">应用</th></tr></thead><tbody><tr><td align="center">JZ</td><td align="center">如果为0则跳转</td><td align="center">jump if zero</td><td align="center">ZF &#x3D; 1</td><td align="center">if（i &#x3D;&#x3D; 0）</td></tr><tr><td align="center">JE</td><td align="center">如果相等则跳转</td><td align="center">jump if equal</td><td align="center">ZF &#x3D; 1</td><td align="center">if（i &#x3D;&#x3D; j）</td></tr><tr><td align="center">JNZ</td><td align="center">若为0则不跳转</td><td align="center">jump if not zero</td><td align="center">ZF &#x3D; 0</td><td align="center">if（i !&#x3D; 0）</td></tr><tr><td align="center">JNE</td><td align="center">若不相等则跳转</td><td align="center">jump if not equal</td><td align="center">ZF &#x3D; 0</td><td align="center">if（i !&#x3D; j)</td></tr><tr><td align="center">JS</td><td align="center">若为负数则跳转</td><td align="center">jump if sign</td><td align="center">SF &#x3D; 1</td><td align="center">if（i &lt; 0)</td></tr><tr><td align="center">JNS</td><td align="center">若不为负数则跳转</td><td align="center">jump if not sign</td><td align="center">SF &#x3D; 0</td><td align="center">if (i &gt; 0)</td></tr><tr><td align="center">JP&#x2F;JPE</td><td align="center">若1出现的次数为偶数跳转</td><td align="center">jump if parity（even）</td><td align="center">PF &#x3D; 1</td><td align="center"></td></tr><tr><td align="center">JNP&#x2F;JPO</td><td align="center">若1出现的次数为奇数跳转</td><td align="center">jump if not party（odd）</td><td align="center">PF &#x3D; 0</td><td align="center"></td></tr><tr><td align="center">JO</td><td align="center">若溢出则为0</td><td align="center">jump if overflow</td><td align="center">OF &#x3D; 1</td><td align="center"></td></tr><tr><td align="center">JNO</td><td align="center">若无溢出则跳转</td><td align="center">jump if not overflow</td><td align="center">OF &#x3D; 0</td><td align="center"></td></tr><tr><td align="center">JC</td><td align="center">若进位则跳转</td><td align="center">jump if carry</td><td align="center">CF &#x3D;1</td><td align="center">if（i &lt; j)</td></tr><tr><td align="center">JB</td><td align="center">若低于则跳转</td><td align="center">jump if below</td><td align="center">CF &#x3D; 1</td><td align="center">if（i &lt; j)</td></tr><tr><td align="center">JNAE</td><td align="center">若不高于等于则跳转</td><td align="center">jump if not above equal</td><td align="center">CF &#x3D; 1</td><td align="center">if (i &lt; j)</td></tr><tr><td align="center">JNC</td><td align="center">若无进位则跳转</td><td align="center">jump if not carry</td><td align="center">CF &#x3D; 0</td><td align="center">if（i  &gt; &#x3D;j )</td></tr><tr><td align="center">JNB</td><td align="center">若不小于则跳转</td><td align="center">jump if not below</td><td align="center">CF &#x3D; 0</td><td align="center">if（i &gt;&#x3D; j)</td></tr><tr><td align="center">JAE</td><td align="center">若高于等于则跳转</td><td align="center">jump if above equal</td><td align="center">CF &#x3D; 0</td><td align="center">if（i &gt;&#x3D; j )</td></tr><tr><td align="center">JBE</td><td align="center">若小于等于则跳转</td><td align="center">jump if above equal</td><td align="center">CF &#x3D; 1或 ZF &#x3D; 1</td><td align="center">if（i &lt;&#x3D; j)</td></tr><tr><td align="center">JNA</td><td align="center">若不超过则跳转</td><td align="center">jump if not above</td><td align="center">CF &#x3D; 1或ZF &#x3D;1</td><td align="center">if(i &lt;&#x3D;j)</td></tr><tr><td align="center">JNBE</td><td align="center">若不小于相等则跳转</td><td align="center">jump if not below equal</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">JA</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">JL</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">JNGE</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">JNL</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">JGE</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">JLE</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">JNG</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">JNL</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">JG</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>JCC指令中文含义英文原意检查符号位典型C应用<br>JZ&#x2F;JE若为0则跳转；若相等则跳转jump if zero;jump if equalZF&#x3D;1if (i &#x3D;&#x3D; j);if (i &#x3D;&#x3D; 0);<br>JNZ&#x2F;JNE若不为0则跳转；若不相等则跳转jump if not zero;jump if not equalZF&#x3D;0if (i !&#x3D; j);if (i !&#x3D; 0);<br>JS若为负则跳转jump if signSF&#x3D;1if (i &lt; 0);<br>JNS若为正则跳转jump if not signSF&#x3D;0if (i &gt; 0);<br>JP&#x2F;JPE若1出现次数为偶数则跳转jump if Parity (Even)PF&#x3D;1(null)<br>JNP&#x2F;JPO若1出现次数为奇数则跳转jump if not parity (odd)PF&#x3D;0(null)<br>JO若溢出则跳转jump if overflowOF&#x3D;1(null)<br>JNO若无溢出则跳转jump if not overflowOF&#x3D;0(null)<br>JC&#x2F;JB&#x2F;JNAE若进位则跳转；若低于则跳转；若不高于等于则跳转jump if carry;jump if below;jump if not above equalCF&#x3D;1if (i &lt; j);<br>JNC&#x2F;JNB&#x2F;JAE若无进位则跳转；若不低于则跳转；若高于等于则跳转；jump if not carry;jump if not below;jump if above equalCF&#x3D;0if (i &gt;&#x3D; j);<br>JBE&#x2F;JNA若低于等于则跳转；若不高于则跳转jump if below equal;jump if not aboveZF&#x3D;1或CF&#x3D;1if (i &lt;&#x3D; j);<br>JNBE&#x2F;JA若不低于等于则跳转；若高于则跳转jump if not below equal;jump if aboveZF&#x3D;0或CF&#x3D;0if (i &gt; j);<br>JL&#x2F;JNGE若小于则跳转；若不大于等于则跳转jump if less;jump if not greater equalSF !&#x3D; OFif (si &lt; sj);<br>JNL&#x2F;JGE若不小于则跳转；若大于等于则跳转；jump if not less;jump if greater equalSF &#x3D; OFif (si &gt;&#x3D; sj);<br>JLE&#x2F;JNG若小于等于则跳转；若不大于则跳转jump if less equal;jump if not greaterZF !&#x3D; OF 或 ZF&#x3D;1if (si &lt;&#x3D; sj);<br>JNLE&#x2F;JG若不小于等于则跳转；若大于则跳转jump if not less equal;jump if greaterSF&#x3D;0F 且 ZF&#x3D;0if(si&gt;sj)</p><hr><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>函数调用约定</p><blockquote><p>是函数调用者和被调用的函数体之间关于参数传递、返回值传递、堆栈清除、寄存器使用的一种约定。</p></blockquote><ul><li><h2 id="Cdecl"><a href="#Cdecl" class="headerlink" title="Cdecl"></a>Cdecl</h2></li></ul><p>声明语法为：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">int</span> <span class="hljs-built_in">function</span> (<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b) <span class="hljs-comment">//不加修饰就是C调用约定 </span><br><span class="hljs-keyword">int</span> __cdecl <span class="hljs-built_in">function</span>(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)<span class="hljs-comment">//明确指出C调用约定</span><br></code></pre></td></tr></table></figure><blockquote><p>cdecl–C Declaration的缩写，C语言缺省的调用约定</p><p>cdecl调用约定意味着：</p><ul><li>参数从右向左压入堆栈</li><li>调用者负责清理堆栈</li><li>C调用约定允许函数的参数的个数是不固定的，这也是C语言的一大特色。</li><li>仅在函数名前加上一个下划线前缀，格式为_functionname。</li></ul></blockquote><ul><li><h2 id="Stdcall"><a href="#Stdcall" class="headerlink" title="Stdcall"></a>Stdcall</h2></li></ul><p>声明语法为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">int</span> __stdcall <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>stdcall(pascal)–Standard Call的缩写，C++的标准调用方式<br>在Microsoft C++系列的C&#x2F;C++编译器中，常常用PASCAL宏来声明这个调用约定，类似的宏还有WINAPI和CALLBACK。<br>一般WIN32的函数都是__stdcall</p><p>stdcall的调用约定意味着：</p><ul><li>参数从右向左压入堆栈</li><li>函数自身清理堆栈</li><li>函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸</li></ul></blockquote><ul><li><h2 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h2></li></ul><p>声明语法为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">int</span> fastcall <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>fastcall调用约定意味着：</p><ul><li>函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈</li><li>函数自身清理堆栈</li><li>函数名修改规则同stdcall:函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸</li></ul></blockquote><ul><li><h2 id="thiscall"><a href="#thiscall" class="headerlink" title="thiscall"></a>thiscall</h2></li></ul><blockquote><p>thiscall一C++类成员缺省的调用约定</p><p>thiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。由于成员函数调用还有一个this指针，因此必须特殊处理，thiscall意味着：</p><ul><li><p>参数从右向左入栈</p></li><li><p>如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。如果参数个数确定，this指针通过ecx传递给被调用者。</p></li><li><p>如果参数个数不确定，调用者清理堆栈，否则函数自己清理堆栈</p></li><li><p>对于参数个数不定的情况下，类似cdecl，固定时类似于stdcall，</p></li></ul></blockquote><ul><li><h2 id="C-编译时函数名修饰约定规则："><a href="#C-编译时函数名修饰约定规则：" class="headerlink" title="C++编译时函数名修饰约定规则："></a>C++编译时函数名修饰约定规则：</h2></li><li><p><strong>__stdcall调用约定</strong>：</p></li></ul><blockquote><p>以“?”标识函数名的开始，后跟函数名；</p><p>函数名后面以“@@YG”标识参数表的开始，后跟参数表；</p><p>参数表以代号表示：</p><p>X–void ，</p><p>D–char，</p><p>E–unsigned char，</p><p>F–short，</p><p>H–int，</p><p>I–unsigned int，</p><p>J–long，</p><p>K–unsigned long，</p><p>M–float，</p><p>N–double，</p><p>_N–bool，</p><p>PA–表示指针,后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代表一次重复…</p></blockquote><p>参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型,指针标识在其所指数据类型前；</p><p>参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。</p><p>例如:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">int</span> Test1（<span class="hljs-keyword">char</span> *var1,unsigned <span class="hljs-keyword">long</span>）-----“?Test1@<span class="hljs-meta">@YGHPADK</span><span class="hljs-meta">@Z</span>” <br><span class="hljs-keyword">void</span> Test2（） -----“?Test2@<span class="hljs-meta">@YGXXZ</span>” <br></code></pre></td></tr></table></figure><ul><li><strong>__cdecl调用约定：</strong>_</li></ul><p>规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YA”。</p><ul><li><strong>__fastcall调用约定：</strong>_</li></ul><p>规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YI”。</p><ul><li><strong>函数调用约定导致的常见问题</strong></li></ul><p>如果定义的约定和使用的约定不一致，则将导致堆栈被破坏，导致严重问题，下面是两种常见的问题：</p><p>1.函数原型声明和函数体定义不一致</p><p>2.DLL导入函数时声明了不同的函数约定</p><p><strong>调用函数的代码和被调函数必须采用相同的函数的调用约定，程序才能正常运行。</strong></p><hr><p>x32是x86架构的32位拓展，向后兼容于16位的x86架构。计算机的CPU一次最多能处理32位数据。，当然32位计算机通常也可以处理16位和8位数据。</p><p>x64是x86架构的64位拓展，向后兼容于16位及32位的x86架构。x64于1999年由AMD设计，AMD首次公开64位集以扩展给x86，称为“AMD64”。其后也为英特尔所采用。</p><p>x86是一个intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合，X与处理器没有任何关系，它是一个对所有＊86系统的简单的通配符定义。</p><p>&#x2F;&#x2F;x96dbg是安装x32dbg和x64dbg用的</p><hr><p>各种数据类型字节数</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202304131138318.png" alt="数据类型字节数"></p><hr><p>伪指令又称为伪操作，它是<strong>在对源程序汇编期间由汇编程序处理的操作</strong>，它们可以完成如处理器选择、定义程序模式、定义数据、分配存储区、指示程序结束等功能。</p><hr><h1 id="博客相关"><a href="#博客相关" class="headerlink" title="博客相关"></a>博客相关</h1><p>图片大小</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">xxx.png</span> <span class="hljs-attr">width</span>=<span class="hljs-string">40%</span> /&gt;</span> or <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> =<span class="hljs-string">xxx.png</span> <span class="hljs-attr">width</span>=<span class="hljs-string">100</span> <span class="hljs-attr">height</span>=<span class="hljs-string">100/</span>&gt;</span><br></code></pre></td></tr></table></figure><p>表格：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 空格 </span>|<span class="hljs-string"> 空格 </span>|<br></code></pre></td></tr></table></figure><p>hexo博客不更新，把.deploy_git文件夹删除，再hexo g -d</p><hr><h1 id="作业，程序，进程和线程"><a href="#作业，程序，进程和线程" class="headerlink" title="作业，程序，进程和线程"></a>作业，程序，进程和线程</h1><p>进程</p><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p><p>线程</p><p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p><p>作业：</p><p>作业指用户在一次解决或是一个事务处理过程中要求计算机系统所做的工作的集合。作业由三部分组成，即程序、数据和作业说明书。一个作业可以包含多个程序和多个数据集。作业说明书在系统中生成一个称为作业控制块(job control block，JCB)的表格。该表格登记该作业所要求的资源情况、预计执行时间和执行优先级等。从而，操作系统通过该表了解到作业要求，并分配资源和控制作业中程序和数据的编译、链接、装入和执行等。</p><p>作业是由一系列有序的步骤组成的。作业的完成要经过作业提交、作业收容、作业执行和作业完成4个阶段。在执行一个作业可能会运行多个不同的进程。</p><p>需要说明的是，作业的概念主要用在批处理系统中，而且，在批处理系统中，作业是抢占内存的基本单位。也就是说，批处理系统以作业为单位把程序和数据调入内存以便执行。</p><p>程序：</p><p>程序是一组有序指令的集合，并存放于某种介质中，是一个静态概念。</p><p>进程：</p><p>进程是为使程序能并发执行，且为了对并发执行的程序加以描述和控制而引入的概念。</p><p>在了解进程前，先说明下进程实体。进程实体是由程序段、相关的数据段和PCB三部分组成，是一个能独立运行、独立分配资源和独立接受调动的基本单位。</p><p>现在来说明进程的定义：进程是进程实体的一次执行过程，是系统进行资源分配和调度的一个独立单位。它是一个动态概念。</p><p>线程：</p><p>随着多处理机系统的发展，提高程序的并发执行程度的要求越来越高。为提高系统的并发执行度，进而引入了线程的概念。线程是比进程更小的能独立运行的基本单位（故又称“轻型进程”），更好的提高了程序的并发执行程度充分发挥了多处理机的优势。</p><hr><p>RAM是<strong>随机存取存储器</strong>（random access memory），是计算机<strong>内部存储器</strong>中的一种，也是其中最重要的，计算机和手机中一般把其叫做<strong>（运行）内存</strong>，它的速度要比硬盘快得多，所以用运行程序在RAM中，而存放运行时不用的数据则在硬盘中，什么时候需要数据，便把数据从硬盘中拿到内存，但同时RAM断电会丢失数据，所以我们电脑如果断电了就会丢失原来正在运行的数据。所以，手机中的RAM和电脑中的RAM的概念是相同的，RAM即内存越大，能同时在内存中执行的程序就越多，性能一般是越好的。</p><p>ROM是<strong>只读存储器（Read-Only Memory）</strong>，也是计算机<strong>内部存储器</strong>中的一种，而硬盘是<strong>外部存储器</strong>，<strong>所以对于大学学子来说，考试时你如果把这两个混为一种东西绝对是错误的</strong>，当然，如果出选择题让你选，那么BIOS应该是用到ROM的那个。那么ROM究竟是干什么的，ROM和硬盘是否就没有任何关系呢？这就要从其发展历程说起，早期，乃至现在，我们的主要存储介质都是<strong>磁性存储</strong>，也就是磁盘，分为硬盘和软盘，硬盘不太适合做移动存储，因为其磁头容易损坏，不耐摔，而且体积较大，就算是缩小容量仍然很难缩小其体积，软盘虽然用作移动介质还算方便，但软盘容量过于小，不够用，而光盘虽然容量大但不易擦写，同时体积也不够小，这时就很适合使用<strong>半导体存储介质</strong>——ROM和RAM，ROM用来嵌入电脑主板或者做移动存储介质就很合适了，其体积够小，提供的容量可以比光盘和软盘的大，速度也更快，但成本相对更高，而且早期的ROM因为技术不成熟所以无法擦写，出厂后就只能读数据，所以叫只读存储器，后来随着技术的发展，在ROM的基础上出现了新的半导体存储介质<strong>EPROM和EEPROM</strong>，这两种可擦写，这就不符合ROM的命名，但是由于是在ROM的技术上衍变出来的，所以延用了一部分原来的叫法，此时非易失的半导体存储介质开始得以广泛应用，被大量用于电脑主板的bios和嵌入式存储，而后来在这两种技术的发展上又发展出了<strong>NAND FLASH闪存，</strong>这就是我们现在用的U盘中用到的技术，同样，因为其体积小，容量和速度均不错，现在手机存储中的emmc颗粒也是用的这种技术，所以有手机厂商就把手机的存储容量约定俗成为ROM，其继承ROM断电不丢失数据的特性，而且有着较快的速度。</p><p>那么电脑硬盘和ROM有什么关系呢？由于ROM和硬盘都可以存储数据而且断电不会丢失，而有都广泛运用于电子产品中，所以有人就对两者产生了混淆。硬盘分为两种，一种是<strong>机械硬盘</strong>（即磁盘HDD）,一种是<strong>固态硬盘（SSD），</strong>磁盘和ROM没什么关系，但是固态硬盘就不一样了，固态硬盘用到的颗粒也是<strong>基于NAND FLASH技术</strong>，和u盘以及手机存储有点相似，所以说硬盘和ROM还是有关系的，固态硬盘的存储颗粒是ROM技术发展的产物，<strong>但不能说ROM就是硬盘。</strong></p><hr><p>编译器就是将“一种语言（通常为<a href="https://baike.baidu.com/item/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80/299113?fromModule=lemma_inlink">高级语言</a>）”翻译为“另一种语言（通常为低级语言）”的程序。一个现代编译器的主要<a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/7870986?fromModule=lemma_inlink">工作流程</a>：<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969?fromModule=lemma_inlink">源代码</a> (source code) → <a href="https://baike.baidu.com/item/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/9067800?fromModule=lemma_inlink">预处理器</a> (preprocessor) → 编译器 (compiler) → <a href="https://baike.baidu.com/item/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81/9407934?fromModule=lemma_inlink">目标代码</a> (object code) → <a href="https://baike.baidu.com/item/%E9%93%BE%E6%8E%A5%E5%99%A8/10853221?fromModule=lemma_inlink">链接器</a> (Linker) → 可执行程序 (executables)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;指令执行周期&lt;/p&gt;
&lt;p&gt;取指令，译码，执行&lt;/p&gt;
&lt;p&gt;加载执行程序&lt;/p&gt;
&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>杂七杂八的东西</title>
    <link href="http://example.com/2022/10/01/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <id>http://example.com/2022/10/01/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF/</id>
    <published>2022-09-30T16:00:00.000Z</published>
    <updated>2023-04-25T06:29:00.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="月象"><a href="#月象" class="headerlink" title="月象"></a>月象</h1><ul><li>新月</li></ul><p><img src="/.com//Users\罗\AppData\Roaming\Typora\typora-user-images\image-20230330225236905.png" alt="新月"></p><p>新月是指在农历的每月月初，月球逐渐远离太阳，月牙渐渐露出来的月相。新月时，月亮仅露出一弯月牙，并且朝右弯曲。随着月球运动，月牙越来越大。到初六初七左右，半个月亮已经露出来了，新月就变成了上弦月。从农历月初到初六左右，这段时间的月相都叫新月。</p><p>新月时，天球上月球与太阳相距不超过90°，因此月亮比太阳稍晚升起，稍晚落下。</p><ul><li>峨眉月</li></ul><p>蛾眉月（waxing Crescent moon ），农历月底和月初的月亮或月相。形状如同眉毛，由此得名。分为新月蛾眉月和残月蛾眉月。新月蛾眉月于月初傍晚出现在西方天空，月面朝西，呈反C状。残月蛾眉月是在月末的黎明，出现在东方天空，月面朝东，呈C状。</p><p><img src="https://blogimages-1307841632.cos.ap-guangzhou.myqcloud.com/img/202303302254515.png" alt="image-20230330225422469"></p><ul><li>上弦月</li></ul><p>上弦月是指在农历的每月初七、初八，<a href="https://baike.baidu.com/item/%E6%9C%88%E7%90%83/30767?fromModule=lemma_inlink">月球</a>与太阳相距90°，月球的一半被照亮的<a href="https://baike.baidu.com/item/%E6%9C%88%E7%9B%B8/2747315?fromModule=lemma_inlink">月相</a>。上弦月时，月亮的一半被照亮，为<a href="https://baike.baidu.com/item/%E5%8D%8A%E5%9C%86%E5%BD%A2/8653950?fromModule=lemma_inlink">半圆形</a>。弦在左，弓背在右。随着月球运动，月亮被照亮的范围越来越大，看起来不再是一个半圆形了，这时候上弦月变成了<a href="https://baike.baidu.com/item/%E7%9B%88%E5%87%B8%E6%9C%88/14745757?fromModule=lemma_inlink">盈凸月</a>。</p><h1 id="激素与幸福"><a href="#激素与幸福" class="headerlink" title="激素与幸福"></a>激素与幸福</h1><p>幸福具体是什么<br>幸福是由三种脑内物质构成的</p><p><strong>多巴胺</strong> ，<strong>血清素</strong>，<strong>催产素</strong><br>和三原色相似，这三类脑内物质也能调配出幸福。<br>血清素的幸福:健康的幸福<br>催产素的幸福:爱和人际关系的幸福<br>多巴胺的幸福:钱成功富有名利的幸福<br>幸福是有优先顺序的。<br>首先是血清素然后是催产素最后才是多巴胺<br>如果比起健康更重视成功的话…<br>很容易患上心理和身体上疾患，容易变得不幸<br>应该首先重视健康，然后由轻重缓急地努力。<br>[努力]必须要有[健康]作为基石<br>如果比起爱和人际关系更重视成功的话……<br>会发挥出巨大的反向复利效果。越老越后悔<br>多巴胺的幸福就像是建筑,我们只看得到这个部分,但如果没有挖出足够支撑建筑的地基(血清素和催产素)，那么它就是摇摇欲坠的。</p><hr><p>血清素的幸福到底是什么<br>注意自己的[状态] [心情]<br>身心健康</p><ul><li>感觉很清爽</li><li>可以放松，可以发呆</li><li>注意力非常集中，平常心，可以控制感情，mindfulness的状态</li><li>运动之后心情不错</li><li>在大自然中感觉很舒服</li><li>健康，没有疾患</li></ul><p>如果感觉[心理难受] [状态不好]就一定要重视<br>抑郁症就是究极的血清素分泌不足的情况<br>失去血清素的幸福的状态:<br>心情低落啥都不想做</p><ul><li>情绪不稳定不安易怒容易发火</li><li>身体状态很差</li><li>集中不了注意力</li><li>生病</li><li>不想活了想死</li></ul><p>如果总是忘东西，工作或者学习上老出错，那么很可能血清素不足<br>这是一种在失去之前被当做理所当然的幸福。<br>虽然是[理所当然],但却是[千金不换]的幸福<br>[健康]这种东西是在失去时才发现的。<br>具有血清素幸福的人会被人信赖(状态稳定)<br>催产素的幸福又是什么?<br>和他人的交流，从关系中产生的幸福。</p><ul><li>夫妇关系</li><li>亲子关系</li><li>友情</li><li>社群</li><li>对于自己所属群体的归属感</li><li>宠物</li></ul><p>丧失了催产素的状态</p><ul><li>寂寞没有朋友</li><li>为人际关系苦恼被排斥</li><li>孤立无援</li></ul><hr><p>多巴胺的幸福<br>基本印象就是[成功] [达成]<br>要得到多巴胺的幸福，需要支付[代价]<br>多巴胺是一种[渴求更多]的物质<br>多巴胺是我们[动机] [想要去做]的原动力，有了多巴胺就能更加[努力],作为结果的[自<br>我成长]也会显现。<br>多巴胺的幸福的具体表现</p><ul><li>成功:钱财产富有名利</li><li>动力:目标设定达成，自我成长，报酬</li><li>承认欲望:想被点赞</li><li>快乐物质:食欲快乐爱好</li></ul><p>多巴胺暴走之后，就会形成依存症。<br>对于多巴服报酬系的依赖</p><ul><li>物质依存:酒精药物烟瘾咖啡因</li><li>行动依存:赌博买买买游戏手机网瘾性行为</li><li>人际关系依存:家庭暴力 ( 依然不离开)共依存</li></ul><hr><p>幸福的[意外性质]<br>不明白幸福的性质就无法把它变为自己的东西，幸福不是结果，而是过程</p><ul><li>幸福就在这里<br>[Be]的幸福:每天有人做饭，早起有饭吃，这就是已经存在的催产素的幸福。我<br>们很难有意识地去注意到。要保持它，不失去是需要我们的努力的。<br>[Do]的幸福:多巴胺的幸福</li><li>幸福就在当下<br>一点一滴的小成就也会促进多巴胺的分泌。这就是小幸福。<br>幸福不在未来，就在现在。<br>不是[达成成就]才会获得幸福，而是[在达成成就的路上]<br>多巴胺带来的幸福是会递减的，这是多巴胺的特征。<br>就算这次得到同样的刺激，如果下次没有比这个更多，多巴胺就不会分泌。就算获得了多巴胺，也无法持续下去。<br>不要陷入多巴胺的沼泽:为了更多的奖金和前景，不断加班损害身体。<br>但是血清素和催产素的幸福不会递减。<br>眺望青空一百次，一千次，这种爽快的感觉不会递减。<br>这三种幸福都可以得到。</li></ul><hr><p>[三种幸福]的科学依据<br>血清素是控制人生的指挥者</p><ul><li><p>平时就好好锻炼血清素的话，就能够防止多巴胺的依存症。</p></li><li><p>血清素就像控制[暴走的马]的[马鞭]</p></li><li><p>多分泌催产素就能变得更加健康</p></li><li><p>身体健康:免疫力上升，细胞修复上升，自然治愈力上升。血压下降，脉搏下降。心脏病的发病可能下降</p></li></ul><p>减少压力。</p><ul><li>记忆力学习能力好奇心上升。</li></ul><p>催产素:人际关系的幸福能作为多巴胺的刹车存在，催产素能抑制想要吸烟喝酒的欲望。<br>大家一起做更开心的证据</p><ul><li>不论是做事还是和谁- 起开心，加上了[催产素]的相乘效果，就会更开心。</li><li>催产素是防止|心理状况恶化]的预防物质。</li><li>一个行动就能产生复数脑内物质。比如微笑会同时产生复数脑内物质，运动。</li></ul><hr><p>获得血清素的幸福的七种方法<br>沐浴早晨的阳光节奏运动(有节拍的运动:比如广播体操) 咀嚼</p><ul><li>睡眠:一天6小时以上的睡眠是必须的，最好有7小时以上。不要只看时间，睡眠的质量也很重要。睡前力量小时不要喝酒吃东西，bluelight(电脑手机)</li><li>运动:为了健康的最低运动量是: -天20分钟的快走。有氧运动和无氧都很重要。</li><li>一小时都坐着对身体很不好。</li><li>小时到了要有意识地站起来动–下。</li><li>早晨散步:起床后一小时内，15到30分钟的散步。</li><li>稍微走快一点，有节奏地走。</li><li>沐浴阳光很重要。</li><li>没必要勉强自己做高强度的运动。</li><li>幸福的存钱罐。</li><li>每天都变得幸福一一点，十年后会获得[幸福的人生]。</li><li>注意不到[小小的幸福]的人，也注意不到[大的幸福]。</li><li>重视自己状态的信号。</li><li>完全注意不到自己身体心理异样，最后会变得很严重。</li></ul><h1 id="爱情？"><a href="#爱情？" class="headerlink" title="爱情？"></a>爱情？</h1><p>爱情三角理论由美国心理学家斯腾伯格提出，认为爱情由三个基本成分组成：激情、亲密和承诺。</p><p>激情是爱情中的性欲成分，是情绪上的着迷；亲密是指在爱情关系中能够引起的温暖体验；承诺指维持关系的担保。</p><p>这三种成分构成了喜欢式爱情、迷恋式爱情等 7 种类型。下面将对三个要素简单的介绍，最后对 7 种类型做出介绍。</p><p>三要素：</p><ul><li>亲密（Intimacy）</li></ul><p>亲密包括热情、理解、沟通、支持和分享等爱情关系中常见的特征，一般来说包含下面十个基本要素：</p><ol><li><p>渴望促进被爱者的幸福，在必要时也希望对方能这么做</p></li><li><p>跟被爱者在一起时感到幸福</p></li><li><p>尊重对方</p></li><li><p>跟被爱方互相理解</p></li><li><p>与被爱方分享自我和自己的占有物</p></li><li><p>从被爱方接受感情上的支持</p></li><li><p>给予被爱方感情上的支持</p></li><li><p>跟被爱方亲切沟通</p></li><li><p>尊重被爱方</p></li><li><p>珍重被爱方</p></li></ol><ul><li>激情（Passion）</li></ul><p>激情的主要特征为性的唤醒和欲望，是一种强烈地想要和对方结合的状态，简单来说，就是见了对方，会有一种怦然心动的感觉，和对方相处，有一种兴奋的体验。激情可以是积极的，也可以是消极的。</p><p>激情经历 3 个阶段：</p><ol><li><p>由于意识控制减弱，身体的变化和表情动作越来越失去控制。人的行为服从于所体验的情感。</p></li><li><p>人失去意志的监督，发生不可控制的动作和失去理智的行为，这些动作在事后回想起来会感到羞耻和后悔。</p></li><li><p>出现在激情爆发之后，此时会出现平静和某种疲劳的现象，严重时会出现精力衰竭，对一切事物都抱着不关心的态度，有事还会精神萎靡，即所谓激情休克。</p></li></ol><ul><li>承诺（Commitment）</li></ul><p>承诺是指投身于爱情和努力维护爱情的决心。如果说亲密是情感性的，激情是驱动性的，那承诺就是认知性的。</p><p>它由两方面组成：短期的和长期的。</p><ol><li><p>短期方面就是要做出一个爱不爱对方的决定</p></li><li><p>长期方面就是做出维护爱情关系的长期的承诺。</p></li></ol><p>恋情发展的四类形式：</p><ol><li><p>加速-停止型：起初进展极快，然後逐渐缓慢，无法走入婚姻；</p></li><li><p>加速型：速度不若加速-停止型快，走得顺畅，感情有增无减；</p></li><li><p>中度型：速度较前两型慢；</p></li><li><p>延长型：步调慢，长路多年，也许有结果，也许说分手。</p></li></ol><p>八种爱情类型（看看自己是哪一种）</p><ol><li><p>无爱式：亲密、激情和承诺三者都缺失，爱情就不存在。两个人可能仅仅是泛泛之交而不是朋友，彼此的关系是随意、肤浅和不受约束的。</p></li><li><p>喜欢式：当亲密程度高，但激情和承诺都非常低时，只有亲密，在一起时感觉很舒服，多表现为友谊。</p></li><li><p>迷恋式：缺乏亲密或承诺，却又强烈的激情。认为对方有强烈的吸引力，但除此之外，对对方的了解不多，也没有想过将来，就像初恋，或一夜情。</p></li><li><p>空洞式：只有承诺，缺乏亲密和激情。常见于激情燃尽的爱情关系中，既没有温情也没有激情，仅仅在一起过日子，如包办婚姻等，纯粹为了结婚的爱情。</p></li><li><p>浪漫式：有着强烈的亲密体验和激情体验，但缺乏承诺。崇尚过程，不在乎结果。</p></li><li><p>伴侣式：亲密和承诺结合在一起所形成的爱，双方会努力维持深刻、长久的友谊，这种爱情表现出亲近、沟通、分享以及对爱情关系的巨大投入。像长久而幸福的婚姻，虽然激情已经逐渐消失。</p></li><li><p>愚昧式：却是亲密的激情和承诺会产生愚蠢的爱情体验，这种爱情会发生在旋风般的求爱中，在压倒一切的激情基础上双方会闪电般击昏，但并不是很了解或者喜欢对方。</p></li><li><p>完美爱情：同时具备三要素，但这种爱情一般认为短时间里容易做到，但很难长久维持。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;月象&quot;&gt;&lt;a href=&quot;#月象&quot; class=&quot;headerlink&quot; title=&quot;月象&quot;&gt;&lt;/a&gt;月象&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;新月&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/.com//Users\罗\AppData\Roaming\Typora</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>日记</title>
    <link href="http://example.com/2022/10/01/%E6%97%A5%E8%AE%B0/"/>
    <id>http://example.com/2022/10/01/%E6%97%A5%E8%AE%B0/</id>
    <published>2022-09-30T16:00:00.000Z</published>
    <updated>2023-03-27T00:01:23.545Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="33ce420ed77c75ae5a1e3baad6a200a61fbd8520c0be474ff0b95caba26cd0ce">98b9bce3395e8307c58744c1268884247d0a5b3479230fb31ca4bed820a86c27422cc91a4ea7f27c7326dd970a974961d932a75619370158c1ac5c95281050db413f7a6cf0dd06320e44b09e0d148775bab7f9ee61722aaf85a226c4934152a5739e168613ce305d7b6be75fc6ffd788d31c93fdd262684b9b97f961610e2b45</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">仅用于个人记录</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Enter password to read.</summary>
    
    
    
    <category term="日常记录" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="日常记录" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/09/11/helloworld/"/>
    <id>http://example.com/2022/09/11/helloworld/</id>
    <published>2022-09-11T12:08:09.403Z</published>
    <updated>2023-03-29T09:34:04.068Z</updated>
    
    <content type="html"><![CDATA[<p>hi~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hi~&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
